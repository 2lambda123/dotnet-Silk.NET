using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Silk.NET.Core.Native;

namespace Silk.Net.Vulkan;

/// <summary>
///  Static class for creating Managed Chains.
/// </summary>
public static class ManagedChain
{
    /// <summary>
    /// Creates a new <see cref="ManagedChain{TChain,T1,T2}"/> with 3 items.
    /// </summary>
    /// <param name="head">The first item.</param>
    /// <param name="item1">The second item.</param>
    /// <param name="item2">The third item.</param>
    /// <typeparam name="TChain">The chain type</typeparam>
    /// <typeparam name="T1">Type of the second item.</typeparam>
    /// <typeparam name="T2">Type of the third item.</typeparam>
    /// <returns></returns>
    public static ManagedChain<TChain, T1, T2> Create<TChain, T1, T2>(TChain head = default, T1 item1 = default,
        T2 item2 = default)
        where TChain : struct, IChainStart
        where T1 : struct, IExtendsChain<TChain>
        where T2 : struct, IExtendsChain<TChain>
        => new ManagedChain<TChain, T1, T2>(head, item1, item2);
}

// This should be autogenerated like Tuple<...>, only showing 3 arg type...

public unsafe class ManagedChain<TChain, T1, T2> : IDisposable
where TChain : struct, IChainStart
where T1 : struct, IExtendsChain<TChain>
where T2 : struct, IExtendsChain<TChain>
{
    private IntPtr _headPtr;
    /// <summary>
    /// Gets a pointer to the current head.
    /// </summary>
    public Chain* HeadPtr => (Chain*) _headPtr;
    
    /// <summary>
    /// Gets or sets the head of the chain.
    /// </summary>
    public TChain Head
    {
        get => Unsafe.AsRef<TChain>((Chain*) _headPtr);
        set
        {
            value.StructureType();
            var nextPtr = ((Chain*) _headPtr)->PNext;
            Marshal.StructureToPtr(value, _headPtr, true);
            ((Chain*) _headPtr)->PNext = nextPtr;
        }
    }

    private IntPtr _item1Ptr;
    /// <summary>
    /// Gets a pointer to the second item in the chain.
    /// </summary>
    public Chain* Item1Ptr => (Chain*) _item1Ptr;
    
    /// <summary>
    /// Gets or sets the second item in the chain.
    /// </summary>
    public T1 Item1 
    {
        get => Unsafe.AsRef<T1>((Chain*) _item1Ptr);
        set
        {
            value.StructureType();
            var nextPtr = ((Chain*) _item1Ptr)->PNext;
            Marshal.StructureToPtr(value, _item1Ptr, true);
            ((Chain*) _item1Ptr)->PNext = nextPtr;
        }
    }
    
    private IntPtr _item2Ptr;
    /// <summary>
    /// Gets a pointer to the third item in the chain.
    /// </summary>
    public Chain* Item2Ptr => (Chain*) _item2Ptr;
    
    /// <summary>
    /// Gets or sets the third item in the chain.
    /// </summary>
    public T2 Item2
    {
        get => Unsafe.AsRef<T2>((Chain*) _item2Ptr);
        set
        {
            value.StructureType();
            var nextPtr = ((Chain*) _item2Ptr)->PNext;
            Marshal.StructureToPtr(value, _item2Ptr, true);
            ((Chain*) _item2Ptr)->PNext = nextPtr;
        }
    }

    /// <summary>
    /// Creates a new <see cref="ManagedChain{TChain,T1,T2}"/> with 3 items.
    /// </summary>
    /// <param name="head">The first item.</param>
    /// <param name="item1">The second item.</param>
    /// <param name="item2">The third item.</param>
    public ManagedChain(TChain head = default, T1 item1 = default, T2 item2 = default)
    {
        _headPtr = Marshal.AllocHGlobal(Marshal.SizeOf<TChain>());
        head.StructureType();
        Marshal.StructureToPtr(head, _headPtr, false);
        
        _item1Ptr = Marshal.AllocHGlobal(Marshal.SizeOf<T1>());
        item1.StructureType();
        Marshal.StructureToPtr(item1, _item1Ptr, false);
        ((Chain*)_headPtr)->PNext = (Chain*) _item1Ptr;
        
        _item2Ptr = Marshal.AllocHGlobal(Marshal.SizeOf<T1>());
        item2.StructureType();
        Marshal.StructureToPtr(item2, _item2Ptr, false);
        ((Chain*)_item1Ptr)->PNext = (Chain*) _item2Ptr;
    }

    /// <inheritdoc />
    public void Dispose()
    {
        var headPtr = Interlocked.Exchange(ref _headPtr, IntPtr.Zero);
        if (headPtr == IntPtr.Zero) return;
        Marshal.DestroyStructure<TChain>((IntPtr)headPtr);
        Marshal.FreeHGlobal(headPtr);
        
        var item1Ptr = Interlocked.Exchange(ref _item1Ptr, IntPtr.Zero);
        Marshal.DestroyStructure<TChain>((IntPtr)item1Ptr);
        Marshal.FreeHGlobal(item1Ptr);
        
        var item2Ptr = Interlocked.Exchange(ref _item2Ptr, IntPtr.Zero);
        Marshal.DestroyStructure<TChain>((IntPtr)item2Ptr);
        Marshal.FreeHGlobal(item2Ptr);
    }
}