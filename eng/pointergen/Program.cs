// See https://aka.ms/new-console-template for more information

static IEnumerable<IEnumerable<bool>> MutabilityCombinations(int current)
{
    for (bool isFirstMut = false, done = false; !done; (isFirstMut, done) = (!isFirstMut, isFirstMut || done))
    {
        if (current == 0)
        {
            yield return Enumerable.Repeat(isFirstMut, 1);
        }
        else
        {
            foreach (var nextMutabilityCombinations in MutabilityCombinations(current - 1))
            {
                yield return Enumerable.Repeat(isFirstMut, 1).Concat(nextMutabilityCombinations);
            }
        }
    }
}

if (!File.Exists("pointergen.csproj"))
{
    throw new InvalidOperationException("Run this in the pointergen directory.");
}

const int maxIndirection = 3;
for (var indirectionLevels = 0; indirectionLevels < maxIndirection; indirectionLevels++)
{
    var mutabilityCombinations = MutabilityCombinations(indirectionLevels).Select(x => x.ToArray()).ToArray();
    foreach (var mutabilityCombination in mutabilityCombinations)
    {
        for (bool typed = false, done = false; !done; (typed, done) = (!typed, typed || done))
        {
            Console.WriteLine(Writer.TypeName(mutabilityCombination));
        }
    }
}

class Writer : IDisposable
{
    private const string PREAMBLE = @"""// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

// ============================================= THIS FILE IS AUTOGENERATED ============================================
// ================================ Please make any edits in eng/pointergen/Program.cs! ================================
// ============================================= THIS FILE IS AUTOGENERATED ============================================

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using InlineIL;

namespace Silk.NET.Core;

""";

    private StreamWriter _sw;
    private string _typeName;
    private bool[] _mutabilityMatrix;
    private bool _isTyped;
    private string _indent = string.Empty;

    public Writer(bool[] mutabilityMatrix, bool typed)
    {
        _typeName = TypeName(mutabilityMatrix);
        _sw = new StreamWriter($"../../sources/Core/Pointers/{_typeName}{(typed ? "`1" : string.Empty)}.gen.cs");
        _mutabilityMatrix = mutabilityMatrix;
        _isTyped = typed;
        _sw.WriteLine(PREAMBLE);
    }

    public void WriteLine(string chars) => _sw.WriteLine(_indent + chars);

    public void Write()
    {
        WriteLine(
            $"public partial readonly ref struct {_typeName}{(_isTyped ? "<T> where T: unmanaged" : string.Empty)}");
        WriteLine("{");
        _indent += "    ";
        WriteLine("/// <summary>");
        WriteLine("/// The underlying reference.");
        WriteLine("/// </summary>");
        var roRef = _mutabilityMatrix[0] ? string.Empty : " readonly";
        var inOrRef = _mutabilityMatrix[0] ? "ref" : "in";
        var lesser = _mutabilityMatrix.Length == 1
            ? string.Empty
            : $"{TypeName(_mutabilityMatrix.AsSpan()[1..])}{(_isTyped ? "<T>" : string.Empty)}";
        WriteLine(_mutabilityMatrix.Length > 1 || !_isTyped
            ? $"public readonly ref{roRef} byte InteriorRef;"
            : $"public readonly ref{roRef} T Ref;\n");

        WriteLine("/// <summary>");
        WriteLine("/// Creates a pointer with the given underlying ref.");
        WriteLine("/// </summary>");
        WriteLine("/// <param name=\"ref\">The underlying ref.</param>");
        var thisTypeRef = _isTyped
            ? $"TypeRef.Type(typeof({_typeName}<>).MakeGenericType(typeof(T)))"
            : $"TypeRef.Type(typeof({_typeName}))";
        if (_mutabilityMatrix.Length == 1)
        {
            WriteLine(_isTyped
                ? $"public {_typeName}({inOrRef} T @ref) => Ref = ref Unsafe.AsRef(in @ref);\n"
                : $"private {_typeName}({inOrRef} byte @ref) => InteriorRef = ref Unsafe.AsRef(in @ref);\n");
        }
        else
        {
            WriteLine($"public {_typeName}({inOrRef} {lesser} @ref)");
            WriteLine("{");
            _indent += "    ";
            WriteLine("IL.Emit.Ldarg_0();");
            WriteLine("IL.Emit.Ldarg_1();");
            WriteLine($"IL.Emit.Stfld(FieldRef.Field({thisTypeRef}, nameof(InteriorRef))));");
            WriteLine("IL.Emit.Ret();");
            WriteLine("throw IL.Unreachable();");
            _indent = _indent[..^4];
            WriteLine("}\n");
        }

        WriteLine("/// <summary>");
        WriteLine("/// Creates a pointer with the given underlying ref.");
        WriteLine("/// </summary>");
        WriteLine("/// <param name=\"ref\">The underlying ref.</param>");
        WriteLine("/// <returns>The created pointer.</returns>");
        if (_mutabilityMatrix.Length == 1)
        {
            WriteLine($"public static {_typeName}{(_isTyped ? "<T>" : string.Empty)} " +
                      $"Create{(_isTyped ? string.Empty : "<T>")}({inOrRef} T @ref)" +
                      (_isTyped
                          ? $" => new({inOrRef} @ref);\n"
                          : $" => new({inOrRef} Unsafe.As<T, byte>(ref Unsafe.AsRef(in @ref)));\n"));
        }
        else
        {
            WriteLine(
                $"public static {_typeName}{(_isTyped ? "<T>" : string.Empty)} Create" +
                $"({inOrRef} {lesser} @ref) " +
                $"=> new({inOrRef} @ref);\n");
        }

        WriteLine("/// <summary>");
        WriteLine("/// Gets the underlying reference.");
        WriteLine("/// </summary>");
        WriteLine("/// <returns>The underlying reference.</returns>");
        WriteLine("/// <remarks>");
        WriteLine($"/// This function allows a <see cref=\"{_typeName}{(_isTyped ? "{T}" : string.Empty)}\"/> " +
                  "to be used in a <c>fixed</c> statement.");
        WriteLine("/// </remarks>");
        if (_mutabilityMatrix.Length == 1)
        {
            WriteLine($"public ref{(_mutabilityMatrix[0] ? string.Empty : " readonly")} " +
                      $"{(_isTyped ? "<T>" : string.Empty)} GetPinnableReference() => ref " +
                      $"{(_isTyped ? "Ref" : "InteriorRef")};\n");
        }
        else
        {
            WriteLine(
                $"public ref{(_mutabilityMatrix[0] ? string.Empty : " readonly")} " +
                $"{(_isTyped ? "T" : "void")}{new string('*', _mutabilityMatrix.Length - 1)} GetPinnableReference()");
            WriteLine("{");
            _indent += "    ";
            WriteLine("IL.Emit.Ldarg_0();");
            WriteLine($"IL.Emit.Ldfld(FieldRef.Field({thisTypeRef}, nameof(InteriorRef))));");
            WriteLine("IL.Emit.Ret();");
            WriteLine("throw IL.Unreachable();");
            _indent = _indent[..^4];
            WriteLine("}\n");
        }

    }

    internal static string TypeName(ReadOnlySpan<bool> mutabilityMatrix)
    {
        Span<char> ret = stackalloc char[mutabilityMatrix.Length * 3];
        for (var i = 0; i < mutabilityMatrix.Length; i++)
        {
            (mutabilityMatrix[i] ? "Mut" : "Ptr").CopyTo(ret[(i * 3)..((i + 1) * 3)]);
        }

        return ret.ToString();
    }

    public void Dispose() => _sw.Dispose();
}
