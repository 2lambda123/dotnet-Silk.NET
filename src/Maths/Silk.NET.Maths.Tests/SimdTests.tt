// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

// this file is generated by T4-template with the same name.

#if NETCOREAPP3_1_OR_GREATER
using System;
using System.Numerics;
using Xunit;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;


namespace Silk.NET.Maths.Tests
{
    internal unsafe static class SimdTestsUtils
    {
        internal static void FillWithRandomData(void* ptr, int len)
        {
            var rand = new Random(10);
            for (int i = 0; i < len; i++)
                *((byte*)ptr + i) = (byte)rand.Next(4, 12);
        }
    }

    public unsafe class SimdTests_Constants
    {
        static bool AreEqual<T>(T a, T b) where T : unmanaged
        {
            if (sizeof(T) == 1)
                return Unsafe.As<T, byte>(ref a) == Unsafe.As<T, byte>(ref b);
            if (sizeof(T) == 2)
                return Unsafe.As<T, ushort>(ref a) == Unsafe.As<T, ushort>(ref b);
            if (sizeof(T) == 4)
                return Unsafe.As<T, uint>(ref a) == Unsafe.As<T, uint>(ref b);
            if (sizeof(T) == 8)
                return Unsafe.As<T, ulong>(ref a) == Unsafe.As<T, ulong>(ref b);
            throw new($"Unexpected type {typeof(T)}");
        }
<# foreach (var bitness in new [] { 64, 128, 256 }) { #>
<# foreach (var constant in new [] { "Epsilon", "MaxValue", "MinValue", "NaN", "NegativeInfinity", "PositiveInfinity", "One", "Two", "MinusOne", "MinusTwo", "E", "Pi", "PiOver2", "Tau", "MaxValueOver2", "AllBitsSet" }) { #>
<# foreach (var type in new [] { "byte", "sbyte", "ushort", "short", "uint", "int", "ulong", "long", "float", "double" }) {#>
        [Fact]
        public void Simd<#= bitness #>_<#= constant #>_<#= type #>()
        {
            for (int i = 0; i < Vector<#= bitness #><<#= type #>>.Count; i++)
                Assert.True(AreEqual(Scalar<<#= type #>>.<#= constant #>, Simd<#= bitness #><<#= type #>>.<#= constant #>.GetElement(i)), $"\nExpected: {Scalar<<#= type #>>.<#= constant #>}\nActual: {Simd<#= bitness #><<#= type #>>.<#= constant #>.GetElement(i)}");
        }
<# } #>
<# } #>
<# } #>
    }

    // Vector x Vector -> Vector
    public unsafe class SimdTests_Vector_Vector_Vector
    {
<# foreach (var bitness in new [] { 64, 128, 256 }) { #>
<# foreach (var method in new [] { "GreaterThan", "LessThan", "GreaterThanOrEqual", "LessThanOrEqual", "Add", "Subtract", "Multiply", "Divide", "And", "Xor", "Or", "Min", "Max", "Equal", "NotEqual" }) { #>
<# foreach (var type in new [] { "byte", "sbyte", "ushort", "short", "uint", "int", "ulong", "long", "float", "double" }) {#>
        [Fact]
        public void Simd<#= bitness #>_<#= method #>_<#= type #>()
        {
            Vector<#= bitness #><<#= type #>> a, b;
            SimdTestsUtils.FillWithRandomData(&a, <#= bitness / 8 #>); 
            SimdTestsUtils.FillWithRandomData(&b, <#= bitness / 8 #>);
            var actual = Simd<#= bitness #>.<#= method #>(a, b);
            for (int i = 0; i < Vector<#= bitness #><<#= type #>>.Count; i++)
<# var boolProcess = method is "Add" or "Subtract" or "Multiply" or "Divide" or "Min" or "Max" or "And" or "Xor" or "Or" ? "" : $" ? Scalar<{type}>.AllBitsSet : Scalar<{type}>.Zero"; #>
            {
                var expected = Scalar.<#= method #>(a.GetElement(i), b.GetElement(i))<#= boolProcess #>;
<# var nanProcess = type is "float" or "double" ? $" || {type}.IsNaN(expected) && {type}.IsNaN(actual.GetElement(i))" : ""; #>
                Assert.True(expected == actual.GetElement(i)<#= nanProcess #>, $"\nId {i}\na[i]: {a.GetElement(i)}\nb[i]: {b.GetElement(i)}\nActual[i]: {actual.GetElement(i)}\nExpected: {expected}");
            }
        }
<# } #>
<# } #>
<# } #>
    }


    // Vector -> Vector
    public unsafe class SimdTests_Vector_Vector
    {
<# foreach (var bitness in new [] { 64, 128, 256 }) { #>
<# foreach (var method in new [] { "Not", "Abs" }) { #>
<# foreach (var type in new [] { "byte", "sbyte", "ushort", "short", "uint", "int", "ulong", "long", "float", "double" }) {#>
        [Fact]
        public void Simd<#= bitness #>_<#= method #>_<#= type #>()
        {
            Vector<#= bitness #><<#= type #>> a;
            SimdTestsUtils.FillWithRandomData(&a, <#= bitness / 8 #>); 
            var actual = Simd<#= bitness #>.<#= method #>(a);
            for (int i = 0; i < Vector<#= bitness #><<#= type #>>.Count; i++)
            {
                var expected = Scalar.<#= method #>(a.GetElement(i));
<# var nanProcess = type is "float" or "double" ? $" || {type}.IsNaN(expected) && {type}.IsNaN(actual.GetElement(i))" : ""; #>
                Assert.True(expected == actual.GetElement(i)<#= nanProcess #>, $"\nId {i}\na[i]: {a.GetElement(i)}\nActual[i]: {actual.GetElement(i)}\nExpected: {expected}");
            }
        }
<# } #>
<# } #>
<# } #>
    }
}
#endif