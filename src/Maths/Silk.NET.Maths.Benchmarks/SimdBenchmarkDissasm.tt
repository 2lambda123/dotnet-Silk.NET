// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

#if NET5_0_OR_GREATER

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Engines;
using BenchmarkDotNet.Jobs;
using System.Runtime.Intrinsics;


namespace Silk.NET.Maths.Benchmark
{
    [SimpleJob(RuntimeMoniker.Net50, launchCount: 1, warmupCount: 3, targetCount: 3)]
    [DisassemblyDiagnoser(exportHtml: true)]
    public unsafe class SIMDDisasm
    {
        const int IterCount = 30;
        void* a;
        void* b;
        void* c;
        
        [GlobalSetup]
        public void Setup()
        {
            // native memory is not a thing on .net 5
            var byteCount = 256/*bits*/ / 8 * IterCount;
            a = (void*)Marshal.AllocHGlobal(byteCount);
            b = (void*)Marshal.AllocHGlobal(byteCount);
            c = (void*)Marshal.AllocHGlobal(byteCount);
            var rand = new Random();
            for (int i = 0; i < byteCount; i++)
            {
                *(byte*)a = (byte)rand.Next(1, 255);
                *(byte*)b = (byte)rand.Next(1, 255);
            }
        }

<# foreach (var type in new [] { "byte", "sbyte", "ushort", "short", "uint", "int", "ulong", "long", "float", "double" }) {#>
<# foreach (var bitness in new [] { 64, 128, 256 }) { #>
<# foreach (var method in new [] { "GreaterThan", "LessThan", "GreaterThanOrEqual", "LessThanOrEqual", "Add", "Subtract", "Multiply", "Divide", "Min", "Max", "Equal", "NotEqual" }) { #>
        [Benchmark]
        public void Simd<#= bitness #><#= method #>_<#= type #>()
        {
            for (int i = 0; i < IterCount * (<#= 256 / bitness #>); i++)
                *((Vector<#= bitness #><<#= type #>>*)c + i) = Simd<#= bitness #>.<#= method #>(*((Vector<#= bitness #><<#= type #>>*)a + i), *((Vector<#= bitness #><<#= type #>>*)b + i)); 
        }
<# } #>
<# } #>
<# } #>
    }
}
#endif