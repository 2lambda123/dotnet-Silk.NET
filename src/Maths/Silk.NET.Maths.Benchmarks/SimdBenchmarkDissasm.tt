// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Engines;
using BenchmarkDotNet.Jobs;
using System.Runtime.Intrinsics;


namespace Silk.NET.Maths.Benchmark
{
    [SimpleJob(RuntimeMoniker.Net50, launchCount: 3, warmupCount: 3, targetCount: 3)]
    [DisassemblyDiagnoser(exportHtml: true)]
    public unsafe class SIMDDisasm
    {
        const int IterCount = 20;
        void* a;
        void* b;
        void* c;
        
        [GlobalSetup]
        public void Setup()
        {
            // native memory is not a thing on .net 5
            a = (void*)Marshal.AllocHGlobal(256/*bits*/ / 8 * IterCount);
            b = (void*)Marshal.AllocHGlobal(256/*bits*/ / 8 * IterCount);
            c = (void*)Marshal.AllocHGlobal(256/*bits*/ / 8 * IterCount);
        }

<# foreach (var type in new [] { "byte", "sbyte", "ushort", "short", "uint", "int", "ulong", "long", "float", "double" }) {#>
<# foreach (var bitness in new [] { 64, 128, 256 }) { #>
<# foreach (var method in new [] { "GreaterThan", "LessThan", "GreaterThanOrEqual", "LessThanOrEqual", "Add", "Subtract", "Multiply", "Divide", "Min", "Max", "Equal", "NotEqual" }) { #>
        [Benchmark]
        public void Simd<#= bitness #><#= method #>_<#= type #>()
        {
            for (int i = 0; i < IterCount * (<#= 256 / bitness #>); i++)
                *((Vector<#= bitness #><<#= type #>>*)c + i) = Simd<#= bitness #>.<#= method #>(*((Vector<#= bitness #><<#= type #>>*)a + i), *((Vector<#= bitness #><<#= type #>>*)b + i)); 
        }
<# } #>
<# } #>
<# } #>
    }
}