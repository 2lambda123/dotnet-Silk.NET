<#@ template language="C#" #>
<#@ import namespace="System.Text" #>
<#
    var maximumItems = 16;

    string ParameterDocs(int index, string prefix)
    {
        var builder = new StringBuilder(prefix);
        builder.Append("<param name=\"head\">The head of the chain.</param>");
        for (var i = 1; i < index; i++)
        {
            builder
                .AppendLine()
                .Append(prefix)
                .Append("<param name=\"item")
                .Append(i)
                .Append("\">Item ")
                .Append(i)
                .Append(".</param>");
        }
        return builder.ToString();
    }

    string ParameterTypeDocs(int index, string prefix)
    {
        var builder = new StringBuilder(prefix);
        builder.Append("<typeparam name=\"TChain\">The chain type</typeparam>");
        for (var i = 1; i < index; i++)
        {
            builder
                .AppendLine()
                .Append(prefix)
                .Append("<typeparam name=\"T")
                .Append(i)
                .Append("\">Type of Item ")
                .Append(i)
                .Append(".</typeparam>");
        }
        return builder.ToString();
    }

    string TypeList(int index)
    {
        var builder = new StringBuilder("TChain");
        for (var i = 1; i < index; i++)
        {
            builder
                .Append(", T")
                .Append(i);
        }
        return builder.ToString();
    }

    string ParamList(int index)
    {
        var builder = new StringBuilder("TChain head = default");
        for (var i = 1; i < index; i++)
        {
            builder
                .Append(", T")
                .Append(i)
                .Append(" item")
                .Append(i)
                .Append(" = default");
        }
        return builder.ToString();
    }

    string ArgList(int index)
    {
        var builder = new StringBuilder("head");
        for (var i = 1; i < index; i++)
        {
            builder
                .Append(", item")
                .Append(i);
        }
        return builder.ToString();
    }

    string ConstraintList(int index, string prefix)
    {
        var builder = new StringBuilder(prefix);
        builder.Append("where TChain : struct, IChainStart");
        for (var i = 1; i < index; i++)
        {
            builder
                .AppendLine()
                .Append(prefix)
                .Append("where T")
                .Append(i)
                .Append(" : struct, IExtendsChain<TChain>");
        }
        return builder.ToString();
    }
#>
// ReSharper disable StaticMemberInGenericType
using System.Collections;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace Silk.NET.Vulkan;

/// <summary>
///  Static class for creating Managed Chains.
/// </summary>
public abstract class ManagedChain : IReadOnlyList<IChainable>, IDisposable
{
    /// <inheritdoc />
    public abstract IEnumerator<IChainable> GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    /// <inheritdoc />
    public abstract int Count { get; }
    
    /// <inheritdoc />
    public abstract IChainable this[int index] { get; }

    /// <inheritdoc />
    public abstract void Dispose();

<#
    for (var i = 1; i <= maximumItems; i++)
    {
        var tList = TypeList(i);
#>
    /// <summary>
    /// Creates a new <see cref="ManagedChain{<#= tList #>}"/> with <#= i #> items.
    /// </summary>
<#= ParameterDocs(i, "    /// ") #>
<#= ParameterTypeDocs(i, "    /// ") #>
    /// <returns>A new <see cref="ManagedChain{<#= tList #>}"/> with <#= i #> items.</returns>
    public static ManagedChain<<#= tList #>> Create<<#= tList #>>(<#= ParamList(i) #>)
<#= ConstraintList(i, "        ") #>
    {
        return new(<#= ArgList(i) #>);
    }

    /// <summary>
    /// Loads a new <see cref="ManagedChain{<#= tList #>}"/> with <#= i #> items from an existing unmanaged chain.
    /// </summary>
    /// <param name="errors">Any errors loading the chain.</param>
    /// <param name="chain">The unmanaged chain to use as the basis of this chain.</param>
    /// <returns>A new <see cref="ManagedChain{<#= tList #>}"/> with <#= i #> items.</returns>
    public static ManagedChain<<#= tList #>> Load<<#= tList #>>(out string errors, TChain chain)
<#= ConstraintList(i, "        ") #>
    {
        return new(out errors, chain);
    }

    /// <summary>
    /// Loads a new <see cref="ManagedChain{<#= tList #>}"/> with <#= i #> items from an existing unmanaged chain,
    /// ignoring any errors.
    /// </summary>
    /// <param name="chain">The unmanaged chain to use as the basis of this chain.</param>
    /// <returns>A new <see cref="ManagedChain{<#= tList #>}"/> with <#= i #> items.</returns>
    public static ManagedChain<<#= tList #>> Load<<#= tList #>>(TChain chain)
<#= ConstraintList(i, "        ") #>
    {
        return new(out var _, chain);
    }

<#
    } // for (var i = 1; i <= maximumItems; i++)
#>
}
<#
    for (var i = 1; i <= maximumItems; i++)
    {
        var tList = TypeList(i);
#>

/// <summary>
/// A <see cref="ManagedChain{<#= tList #>}"/> safely manages the pointers of a managed structure chain.
/// </summary>
<#= ParameterTypeDocs(i, "/// ") #>
public unsafe class ManagedChain<<#= tList #>> : ManagedChain
<#= ConstraintList(i, "    ") #>
{
    /// <summary>
    /// Gets the size (in bytes) of the head structure.
    /// </summary>
    public static readonly int HeadSize = Marshal.SizeOf<TChain>();
<#
        for (var j = 1; j < i; j++)
        {
#>

    /// <summary>
    /// Gets the offset to the start of <see cref="Item1"/>.
    /// </summary>
    public static readonly int Item<#= j #>Offset = <#= j == 1 ? "HeadSize" : $"Item{j - 1}Offset + Item{j - 1}Size" #>;

    /// <summary>
    /// Gets the size (in bytes) of the Item 1.
    /// </summary>
    public static readonly int Item<#= j #>Size = Marshal.SizeOf<T<#= j #>>();
<#
        } // for (int j = 1; j < i; j++) {
#>

    /// <summary>
    /// Gets the total size (in bytes) of the unmanaged memory, managed by this chain.
    /// </summary>
    public static readonly int MemorySize = <#= i == 1 ? "HeadSize" : $"Item{i - 1}Offset + Item{i - 1}Size" #>;
    
    private nint _headPtr;

    /// <summary>
    /// Gets a pointer to the current head.
    /// </summary>
    public BaseInStructure* HeadPtr => (BaseInStructure*) _headPtr;

    /// <summary>
    /// Gets or sets the head of the chain.
    /// </summary>
    public TChain Head
    {
        get => Unsafe.AsRef<TChain>((BaseInStructure*) _headPtr);
        set
        {
            value.StructureType();
            var ptr = (BaseInStructure*) _headPtr;
            var nextPtr = ptr->PNext;
            Marshal.StructureToPtr(value, _headPtr, true);
            ptr->PNext = nextPtr;
        }
    }
<#
        for (var j = 1; j < i; j++)
        {
#>

    /// <summary>
    /// Gets a pointer to the second item in the chain.
    /// </summary>
    public BaseInStructure* Item<#= j #>Ptr => (BaseInStructure*) (_headPtr + Item<#= j #>Offset);

    /// <summary>
    /// Gets or sets item #<#= j #> in the chain.
    /// </summary>
    public T<#= j #> Item<#= j #>
    {
        get => Unsafe.AsRef<T<#= j #>>(Item<#= j #>Ptr);
        set
        {
            value.StructureType();
            var ptr = Item<#= j #>Ptr;
            var nextPtr = ptr->PNext;
            Marshal.StructureToPtr(value, (nint)ptr, true);
            ptr->PNext = nextPtr;
        }
    }
<#
        } // for (int j = 1; j < i; j++) {
#>

    /// <summary>
    /// Creates a new <see cref="ManagedChain{<#= tList #>}"/> with <#= i #> items from an existing memory block.
    /// </summary>
    /// <param name="headPtr">The pointer to the head of the chain..</param>
    /// <remarks>
    /// Callers are responsible for ensuring the size of the memory is correct.
    /// </remarks>
    internal ManagedChain(nint headPtr)
    {
        _headPtr = headPtr;
    }

    /// <summary>
    /// Creates a new <see cref="ManagedChain{<#= tList #>}"/> with <#= i #> items.
    /// </summary>
<#= ParameterDocs(i, "    /// ") #>
    public ManagedChain(<#= ParamList(i) #>)
        : this(Marshal.AllocHGlobal(MemorySize))
    {
        head.StructureType();
        Marshal.StructureToPtr(head, _headPtr, false);
<#
        for (var j = 1; j < i; j++)
        {
#>
        <#= j == 1 ? "BaseInStructure* " : "" #>itemPtr = Item<#= j #>Ptr;
        item<#= j #>.StructureType();
        Marshal.StructureToPtr(item<#= j #>, (nint)itemPtr, false);
        <#= j == 1 ? "HeadPtr" : $"Item{j - 1}Ptr" #>->PNext = itemPtr;
<#
        } // for (int j = 1; j < i; j++) {
#>
        <#= i == 1 ? "HeadPtr" : $"Item{i - 1}Ptr" #>->PNext = null;
    }

    /// <summary>
    /// Creates a new <see cref="ManagedChain{<#= tList #>}"/> with <#= i #> items from an existing unmanaged chain.
    /// </summary>
    /// <param name="errors">Any errors loading the chain.</param>
    /// <param name="chain">The unmanaged chain to use as the basis of this chain.</param>
    public ManagedChain(out string errors, TChain chain)
        : this(Marshal.AllocHGlobal(MemorySize))
    {
        chain.StructureType();
        Marshal.StructureToPtr(chain, _headPtr, false);
<#
        if (i == 1)
        {
#>
        errors = string.Empty;
<#
        }
        else
        {
#>
        StringBuilder errorBuilder = new StringBuilder();
        var existingPtr = (BaseInStructure*) Unsafe.AsPointer(ref chain);
        var newPtr = (BaseInStructure*) _headPtr;
<#
            for (var j = 1; j < i; j++)
            {
#>

        existingPtr = (BaseInStructure*)existingPtr->PNext;
        newPtr->PNext = (BaseInStructure*)(_headPtr + Item<#= j #>Offset);
        newPtr = (BaseInStructure*)newPtr->PNext;

        T<#= j #> item<#= j #> = default;
        <#= j == 1 ? "var " : "" #>expectedStructureType = item<#= j #>.StructureType();
        if (existingPtr is null) {
            errorBuilder.AppendLine("The unmanaged chain was length <#= j #>, expected length <#= i #>");
        } else {
            if (existingPtr->SType != expectedStructureType) {
                errorBuilder.Append("The unmanaged chain has a structure type ")
                    .Append(existingPtr->SType)
                    .Append(" at position <#= j + 1 #>; expected ")
                    .Append(expectedStructureType)
                    .AppendLine();
            } else {
<#
                if (j == i - 1)
                {
#>
                if (existingPtr->PNext is not null) {
                    errorBuilder.AppendLine("The unmanaged chain was longer than the expected length <#= i #>");
                    existingPtr->PNext = null;
                }
<#
                } // if (j == i -1)
#>
                item<#= j #> = Unsafe.AsRef<T<#= j #>>(existingPtr);
            }
        }
        Marshal.StructureToPtr(item<#= j #>, (nint) newPtr, false);
<#
            } // for (int j = 1; j < i; j++) {
#>

        // Create string of errors
        errors = errorBuilder.ToString().Trim();
<#
        } // if (i == 1) {} else {...
#>
    }

    /// <summary>
    /// Creates a new <see cref="ManagedChain{<#= tList #>}"/> with <#= i #> by copying this chain.
    /// </summary>
    /// <remarks>
    /// Do not forget to <see cref="IDisposable">dispose</see> this chain if you are no longer using it.
    /// </remarks>
    public ManagedChain<<#= tList #>> Duplicate() 
    {
        var newHeadPtr = Marshal.AllocHGlobal(MemorySize);
        // Block copy original struct data for speed
        System.Buffer.MemoryCopy((void*)_headPtr, (void*)newHeadPtr, MemorySize, MemorySize);
<#
        if (i > 1)
        {
#>
        // Update all pointers
        ((BaseInStructure*)newHeadPtr)->PNext = (BaseInStructure*) (newHeadPtr + Item1Offset); 
<#
        } // if (i > 1)
#>
<#
        for (var j = 2; j < i; j++)
        {
#>
        ((BaseInStructure*)(newHeadPtr + Item<#= j - 1 #>Offset))->PNext = (BaseInStructure*) (newHeadPtr + Item<#= j #>Offset); 
<#
        } // for (int j = 1; j < i; j++) {
#>
        return new ManagedChain<<#= tList #>>(newHeadPtr);
    }
<#
        if (i > 1)
        {
            var shortTList = TypeList(i - 1);
#>

    /// <summary>
    /// Creates a new <see cref="ManagedChain{<#= tList #>}"/> with <#= i #> items, by appending 
    /// <paramref name="item<#= i - 1 #>"/> to the end of this chain.
    /// </summary>
    /// <param name="previous">The chain to append to.</param>
    /// <param name="item<#= i - 1 #>">Item <#= i - 1 #>.</param>
    /// <remarks>
    /// Do not forget to dispose the <paramref name="previous"/> chain if you are no longer using it.
    /// </remarks>
    public ManagedChain(ManagedChain<<#= shortTList #>> previous, T<#= i - 1 #> item<#= i - 1 #> = default)
        : this(Marshal.AllocHGlobal(MemorySize))
    {
        var previousSize = MemorySize - Item<#= i - 1 #>Size;
        // Block copy original struct data for speed
        System.Buffer.MemoryCopy(previous.HeadPtr, (void*)_headPtr, previousSize, previousSize);
        
        // Append item <#= i - 1 #>
        item<#= i - 1 #>.StructureType();        
        Marshal.StructureToPtr(item<#= i - 1 #>, _headPtr + previousSize, false);

        // Update all pointers
        ((BaseInStructure*)_headPtr)->PNext = (BaseInStructure*) (_headPtr + Item1Offset);
<#
            for (var j = 2; j < i; j++)
            {
#>
        ((BaseInStructure*)(_headPtr + Item<#= j - 1 #>Offset))->PNext = (BaseInStructure*) (_headPtr + Item<#= j #>Offset); 
<#
            } // for (int j = 1; j < i; j++) {
#>
        ((BaseInStructure*)(_headPtr + previousSize))->PNext = null;
    }

    /// <summary>
    /// Creates a new <see cref="ManagedChain{<#= shortTList #>}"/> with <#= i - 1 #> items, by removing the last item
    /// from this chain.
    /// </summary>
    /// <remarks>
    /// Do not forget to <see cref="IDisposable">dispose</see> this chain if you are no longer using it.
    /// </remarks>
    public ManagedChain<<#= shortTList #>> Truncate()
    {
        return Truncate(out var _);
    }

    /// <summary>
    /// Creates a new <see cref="ManagedChain{<#= shortTList #>}"/> with <#= i - 1 #> items, by removing 
    /// <paramref name="item<#= i - 1 #>"/> from the end of this chain.
    /// </summary>
    /// <remarks>
    /// Do not forget to <see cref="IDisposable">dispose</see> this chain if you are no longer using it.
    /// </remarks>
    public ManagedChain<<#= shortTList #>> Truncate(out T<#= i - 1 #> item<#= i - 1 #>)
    {
        item<#= i - 1 #> = Item<#= i - 1 #>;

        var newSize = MemorySize - Item<#= i - 1 #>Size;
        var newHeadPtr = Marshal.AllocHGlobal(newSize);
        // Block copy original struct data for speed
        System.Buffer.MemoryCopy((void*)_headPtr, (void*)newHeadPtr, newSize, newSize);
        // Update all pointers
<#
            if (i > 2)
            {
#>
        ((BaseInStructure*)newHeadPtr)->PNext = (BaseInStructure*) (newHeadPtr + Item1Offset);
<#
                for (var j = 2; j < i; j++)
                {
#>
        ((BaseInStructure*)(newHeadPtr + Item<#= j - 1 #>Offset))->PNext = <#= j == i -1 ? "null" : $"(BaseInStructure*) (newHeadPtr + Item{j}Offset)"#>; 
<#
                } // for (int j = 1; j < i - 1; j++)
            }
            else // if (i > 1)
            {
                #>
        ((BaseInStructure*)newHeadPtr)->PNext = null;
<#
            }
#>
        return new ManagedChain<<#= shortTList #>>(newHeadPtr);
    }
<#
        } // if (i > 1)

        if (i < maximumItems)
        {
            var bigTList = TypeList(i + 1);
#>

    /// <summary>
    /// Creates a new <see cref="ManagedChain{<#= tList #>, T<#= i #>}"/> with <#= i + 1 #> items, by appending <paramref name="item<#= i #>"/> to
    /// the end of this chain.
    /// </summary>
    /// <param name="item<#= i #>">Item <#= i #>.</param>
    /// <typeparam name="T<#= i #>">Type of Item <#= i #></typeparam>
    /// <remarks>
    /// Do not forget to <see cref="IDisposable">dispose</see> this chain if you are no longer using it.
    /// </remarks>
    public ManagedChain<<#= bigTList #>> Append<T<#= i #>>(T<#= i #> item<#= i #> = default)
        where T<#= i #>: struct, IExtendsChain<TChain>
    {
        return new ManagedChain<<#= tList #>, T<#= i #>>(this, item<#= i #>);
    }
<#
        } // if (i < maximumItems)
#>

    /// <inheritdoc />
    public override IEnumerator<IChainable> GetEnumerator()
    {
        yield return Head;
<#
        for (var j = 1; j < i; j++)
        {
#>
        yield return Item<#= j #>;
<#
        } // for (int j = 1; j < i; j++) {
#>
    }

    /// <inheritdoc />
    public override int Count => <#= i #>;

    /// <inheritdoc />
    public override IChainable this[int index]
        => index switch 
        {
            0 => Head,
<#
        for (var j = 1; j < i; j++)
        {
#>
            <#= j #> => Item<#= j #>,
<#
        } // for (int j = 1; j < i; j++) {
#>
            _ => throw new IndexOutOfRangeException()
        };

    /// <summary>
    /// Deconstructs this chain.
    /// </summary>
<#= ParameterDocs(i, "    /// ") #>
    public void Deconstruct(out TChain head<#
        for (var j = 1; j < i; j++)
        {
#>, out T<#= j #> item<#= j #><#
        } // for (int j = 1; j < i; j++) {
#>)
    {
            head = Head;
<#
        for (var j = 1; j < i; j++)
        {
#>
            item<#= j #> = Item<#= j #>;
<#
        } // for (int j = 1; j < i; j++) {
#>
    }  

    /// <inheritdoc />
    public override void Dispose()
    {
        var headPtr = Interlocked.Exchange(ref _headPtr, (nint)0);
        if (headPtr == (nint)0) { 
            return;
        }

        // Destroy all structures
        Marshal.DestroyStructure<TChain>(headPtr);
<#
        for (var j = 1; j < i; j++)
        {
#>
        Marshal.DestroyStructure<T<#= j #>>(headPtr + Item<#= j #>Offset);
<#
        } // for (int j = 1; j < i; j++) {
#>

        // Free memory block
        Marshal.FreeHGlobal(headPtr);
    }
}
<#
    } // for (var i = 1; i <= maximumItems; i++)
#>