namespace Silk.NET.GLFW
{
    // Licensed to the .NET Foundation under one or more agreements.
    // The .NET Foundation licenses this file to you under the MIT license.
    using System;
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using Silk.NET.Core.Attributes;
    using Silk.NET.Core.Contexts;
    using Silk.NET.Core.Loader;
    using Silk.NET.Core.Native;
    using UnmanagedType = Silk.NET.Core.Native.UnmanagedType;
    using Silk.NET.Core.Native;
    using Silk.NET.Core.Contexts;

    public partial class Glfw : NativeAPI
    {
        /// <summary>
        /// <para>
        /// This function initializes the GLFW library. Before most GLFW functions can be used,
        /// GLFW must be initialized, and before an application terminates GLFW should be terminated in order to
        /// free any resources allocated during or after initialization.
        /// </para>
        /// <para>
        /// If this function fails, it calls <see cref = "Terminate"/> before returning.
        /// </para>
        /// <para>
        /// If it succeeds, you should call <see cref = "Terminate"/> before the application exits.
        /// </para>
        /// <para>
        /// Additional calls to this function after successful initialization
        /// but before termination will return <c>true</c> immediately.
        /// </para>
        /// </summary>
        /// <returns><c>true</c> if successful, or <c>false</c> if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// OS X: This function will change the current directory of the application
        /// to the Contents/Resources subdirectory of the application's bundle, if present.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public partial bool Init()
        {
            unsafe
            {
                byte n1;
                Console.WriteLine("Begin Init");
                Console.WriteLine("PostInit Init");
                Console.WriteLine("PreLoad Init");
                n1 = ((delegate* unmanaged[Cdecl]<byte> )(CurrentVTable as GeneratedVTable).glfwInit)();
                Console.WriteLine("PostLoad Init");
                Console.WriteLine("End Init");
                return (n1 >= 1);
            }
        }

        /// <summary>
        /// <para>
        /// This function destroys all remaining windows and cursors, restores any modified gamma ramps
        /// and frees any other allocated resources. Once this function is called,
        /// you must again call <see cref = "Init"/> successfully before you will be able to use most GLFW functions.
        /// </para>
        /// <para>
        /// If GLFW has been successfully initialized, this function should be called before the application exits.
        /// </para>
        /// <para>
        /// If initialization fails, there is no need to call this function,
        /// as it is called by <see cref = "Init"/> before it returns failure.
        /// </para>
        /// </summary>
        /// <remarks>
        /// <para>
        /// The contexts of any remaining windows must not be current on any other thread when this function is called.
        /// </para>
        /// <para>
        /// This function may be called before <see cref = "Init"/>.
        /// </para>
        /// <para>
        /// This function must not be called from a callback.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public partial void Terminate()
        {
            unsafe
            {
                Console.WriteLine("Begin Terminate");
                Console.WriteLine("PostInit Terminate");
                Console.WriteLine("PreLoad Terminate");
                ((delegate* unmanaged[Cdecl]<void> )(CurrentVTable as GeneratedVTable).glfwTerminate)();
                Console.WriteLine("PostLoad Terminate");
                Console.WriteLine("End Terminate");
            }
        }

        /// <summary>
        /// <para>
        /// This function sets hints for the next initialization of GLFW.
        /// </para>
        /// <para>
        /// The values you set hints to are never reset by GLFW, but they only take effect during initialization.
        /// </para>
        /// <para>
        /// Once GLFW has been initialized,
        /// any values you set will be ignored until the library is terminated and initialized again.
        /// </para>
        /// <para>
        /// Some hints are platform specific.
        /// These may be set on any platform but they will only affect their specific platform.
        /// Other platforms will ignore them. Setting these hints requires no platform specific headers or functions.
        /// </para>
        /// </summary>
        /// <param name = "hint">The <see cref = "NET.GLFW.InitHint"/> to set.</param>
        /// <param name = "value">The new value of the <see cref = "NET.GLFW.InitHint"/>.</param>
        /// <remarks>
        /// <para>
        /// This function may be called before <see cref = "Init"/>.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.InvalidEnum"/> and <see cref = "ErrorCode.InvalidValue"/>.
        /// </para>
        /// </remarks>
        public partial void InitHint(global::Silk.NET.GLFW.InitHint hint, bool value)
        {
            unsafe
            {
                Console.WriteLine("Begin InitHint");
                Console.WriteLine("PostInit InitHint");
                Console.WriteLine("PreLoad InitHint");
                ((delegate* unmanaged[Cdecl]<int, byte, void> )(CurrentVTable as GeneratedVTable).glfwInitHint)(((int)(hint)), ((value) ? (byte)1 : (byte)0));
                Console.WriteLine("PostLoad InitHint");
                Console.WriteLine("End InitHint");
            }
        }

        /// <summary>
        /// <para>
        /// This function retrieves the major, minor and revision numbers of the GLFW library.
        /// It is intended for when you are using GLFW
        /// as a shared library and want to ensure that you are using the minimum required version.
        /// </para>
        /// <para>
        /// Any or all of the version arguments may be <c>out _</c>.
        /// </para>
        /// </summary>
        /// <param name = "major">Where to store the major version number, or <c>out _</c>.</param>
        /// <param name = "minor">Where to store the minor version number, or <c>out _</c>.</param>
        /// <param name = "revision">Where to store the revision number, or <c>out _</c>.</param>
        /// <remarks>
        /// <para>
        /// This function may be called before <see cref = "Init"/>.
        /// </para>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// </remarks>
        public partial void GetVersion(out int major, out int minor, out int revision)
        {
            unsafe
            {
                Console.WriteLine("Begin GetVersion");
                Console.WriteLine("PostInit GetVersion");
                fixed (int* SPECIAL_VAR3 = &major)
                    fixed (int* SPECIAL_VAR4 = &minor)
                        fixed (int* SPECIAL_VAR5 = &revision)
                        {
                            Console.WriteLine("PreLoad GetVersion");
                            ((delegate* unmanaged[Cdecl]<void*, void*, void*, void> )(CurrentVTable as GeneratedVTable).glfwGetVersion)(((void*)(SPECIAL_VAR3)), ((void*)(SPECIAL_VAR4)), ((void*)(SPECIAL_VAR5)));
                            Console.WriteLine("PostLoad GetVersion");
                            Console.WriteLine("End GetVersion");
                        }
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the compile-time generated version string of the GLFW library binary.
        /// It describes the version, platform, compiler and any platform-specific compile-time options.
        /// It should not be confused with the OpenGL or OpenGL ES version string, queried with <c>glGetString</c>.
        /// </para>
        /// <para>
        /// Do not use the version string to parse the GLFW library version.
        /// The <see cref = "GetVersion"/> function provides the version of the running library binary in numerical format.
        /// </para>
        /// </summary>
        /// <returns>The ASCII-encoded GLFW version string.</returns>
        /// <remarks>
        /// <para>
        /// This function may be called before <see cref = "Init"/>.
        /// </para>
        /// <para>
        /// The returned string is static and compile-time generated.
        /// </para>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// </remarks>
        /// <seealso cref = "GetVersion"/>
        public partial string GetVersionString()
        {
            unsafe
            {
                void* n2;
                Console.WriteLine("Begin GetVersionString");
                Console.WriteLine("PostInit GetVersionString");
                Console.WriteLine("PreLoad GetVersionString");
                n2 = ((delegate* unmanaged[Cdecl]<void*> )(CurrentVTable as GeneratedVTable).glfwGetVersionString)();
                Console.WriteLine("PostLoad GetVersionString");
                Console.WriteLine("End GetVersionString");
                return (Silk.NET.Core.Native.SilkMarshal.PtrToString((global::System.IntPtr)((byte*)n2), (Silk.NET.Core.Native.NativeStringEncoding)20));
            }
        }

        /// <summary>
        /// <para>
        /// This function returns and clears the error code of the last error that occurred on the calling thread,
        /// and optionally a UTF-8 encoded human-readable description of it.
        /// </para>
        /// <para>
        /// If no error has occurred since the last call,
        /// it returns <see cref = "ErrorCode.NoError"/> (zero) and the description pointer is set to <c>null</c>.
        /// </para>
        /// </summary>
        /// <param name = "description">Where to store the error description pointer, or <c>out _</c>"/>.</param>
        /// <returns>The last error code for the calling thread, or <see cref = "ErrorCode.NoError"/> (zero).</returns>
        /// <remarks>
        /// <para>
        /// The returned string is allocated and freed by GLFW. You should not free it yourself.
        /// It is only guaranteed to be valid until the next error occurs or the library is terminated.
        /// </para>
        /// <para>
        /// This function may be called before <see cref = "Init"/>.
        /// </para>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// </remarks>
        /// <seealso cref = "SetErrorCallback"/>
        public unsafe partial global::Silk.NET.GLFW.ErrorCode GetError(out byte* description)
        {
            int n4;
            Console.WriteLine("Begin GetError");
            fixed (byte** SPECIAL_VAR1 = &description)
            {
                Console.WriteLine("PostInit GetError");
                Console.WriteLine("PreLoad GetError");
                n4 = ((delegate* unmanaged[Cdecl]<void*, int> )(CurrentVTable as GeneratedVTable).glfwGetError)(((void*)(SPECIAL_VAR1)));
                Console.WriteLine("PostLoad GetError");
                Console.WriteLine("End GetError");
                return ((Silk.NET.GLFW.ErrorCode)n4);
            }
        }

        /// <summary>
        /// <para>
        /// This function returns an array of handles for all currently connected monitors.
        /// The primary monitor is always first in the returned array.
        /// </para>
        /// <para>
        /// If no monitors were found, this function returns <c>null</c>.
        /// </para>
        /// </summary>
        /// <param name = "count">
        /// Where to store the number of monitors in the returned array. This is set to zero if an error occurred.
        /// </param>
        /// <returns>
        /// An array of monitor handles, or <c>null</c> if no monitors were found or if an error occurred.
        /// </returns>
        /// <remarks>
        /// <para>
        /// The returned array is allocated and freed by GLFW. You should not free it yourself.
        /// It is only guaranteed to be valid until the monitor configuration changes or the library is terminated.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "GetPrimaryMonitor"/>
        public unsafe partial global::Silk.NET.GLFW.Monitor** GetMonitors(out int count)
        {
            void* n4;
            Console.WriteLine("Begin GetMonitors");
            fixed (int* SPECIAL_VAR1 = &count)
            {
                Console.WriteLine("PostInit GetMonitors");
                Console.WriteLine("PreLoad GetMonitors");
                n4 = ((delegate* unmanaged[Cdecl]<void*, void*> )(CurrentVTable as GeneratedVTable).glfwGetMonitors)(((void*)(SPECIAL_VAR1)));
                Console.WriteLine("PostLoad GetMonitors");
                Console.WriteLine("End GetMonitors");
                return ((Silk.NET.GLFW.Monitor**)n4);
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the position, in screen coordinates, of the upper-left corner of the specified monitor.
        /// </para>
        /// </summary>
        /// <param name = "monitor">The monitor to query.</param>
        /// <param name = "x">Where to store the monitor x-coordinate, or <c>out _</c>.</param>
        /// <param name = "y">Where to store the monitor y-coordinate, or <c>out _</c>.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void GetMonitorPos(global::Silk.NET.GLFW.Monitor* monitor, out int x, out int y)
        {
            Console.WriteLine("Begin GetMonitorPos");
            Console.WriteLine("PostInit GetMonitorPos");
            fixed (int* SPECIAL_VAR3 = &x)
                fixed (int* SPECIAL_VAR4 = &y)
                {
                    Console.WriteLine("PreLoad GetMonitorPos");
                    ((delegate* unmanaged[Cdecl]<void*, void*, void*, void> )(CurrentVTable as GeneratedVTable).glfwGetMonitorPos)(((void*)(monitor)), ((void*)(SPECIAL_VAR3)), ((void*)(SPECIAL_VAR4)));
                    Console.WriteLine("PostLoad GetMonitorPos");
                    Console.WriteLine("End GetMonitorPos");
                }
        }

        /// <summary>
        /// <para>
        /// This function returns the size, in millimetres, of the display area of the specified monitor.
        /// </para>
        /// <para>
        /// Some systems do not provide accurate monitor size information,
        /// either because the monitor EDID(Extended Display Identification Data) data is incorrect
        /// or because the driver does not report it accurately.
        /// </para>
        /// <para>
        /// Any or all of the size arguments may be <c>out _</c>.
        /// If an error occurs, all non-<c>out _</c> size arguments will be set to zero.
        /// </para>
        /// </summary>
        /// <param name = "monitor">The monitor to query.</param>
        /// <param name = "width">
        /// Where to store the width, in millimetres, of the monitor's display area, or <c>out _</c>.
        /// </param>
        /// <param name = "height">
        /// Where to store the height, in millimetres, of the monitor's display area, or <c>out _</c>.
        /// </param>
        /// <remarks>
        /// <para>
        /// Windows: calculates the returned physical size from the current resolution
        ///          and system DPI instead of querying the monitor EDID data.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void GetMonitorPhysicalSize(global::Silk.NET.GLFW.Monitor* monitor, out int width, out int height)
        {
            Console.WriteLine("Begin GetMonitorPhysicalSize");
            Console.WriteLine("PostInit GetMonitorPhysicalSize");
            fixed (int* SPECIAL_VAR3 = &width)
                fixed (int* SPECIAL_VAR4 = &height)
                {
                    Console.WriteLine("PreLoad GetMonitorPhysicalSize");
                    ((delegate* unmanaged[Cdecl]<void*, void*, void*, void> )(CurrentVTable as GeneratedVTable).glfwGetMonitorPhysicalSize)(((void*)(monitor)), ((void*)(SPECIAL_VAR3)), ((void*)(SPECIAL_VAR4)));
                    Console.WriteLine("PostLoad GetMonitorPhysicalSize");
                    Console.WriteLine("End GetMonitorPhysicalSize");
                }
        }

        /// <summary>
        /// <para>
        /// This function retrieves the content scale for the specified monitor.
        /// </para>
        /// <para>
        /// The content scale is the ratio between the current DPI and the platform's default DPI.
        /// </para>
        /// <para>
        /// If you scale all pixel dimensions by this scale then your content should appear at an appropriate size.
        /// This is especially important for text and any UI elements.
        /// </para>
        /// <para>
        /// The content scale may depend on both the monitor resolution and pixel density and on user settings.
        /// It may be very different from the raw DPI calculated from the physical size and current resolution.
        /// </para>
        /// </summary>
        /// <param name = "monitor">The monitor to query.</param>
        /// <param name = "xscale">Where to store the x-axis content scale, or <c>out _</c>.</param>
        /// <param name = "yscale">Where to store the y-axis content scale, or <c>out _</c>.</param>
         // ReSharper disable IdentifierTypo
        public unsafe partial void GetMonitorContentScale(global::Silk.NET.GLFW.Monitor* monitor, out float xscale, out float yscale)
        {
            Console.WriteLine("Begin GetMonitorContentScale");
            Console.WriteLine("PostInit GetMonitorContentScale");
            fixed (float* SPECIAL_VAR3 = &xscale)
                fixed (float* SPECIAL_VAR4 = &yscale)
                {
                    Console.WriteLine("PreLoad GetMonitorContentScale");
                    ((delegate* unmanaged[Cdecl]<void*, void*, void*, void> )(CurrentVTable as GeneratedVTable).glfwGetMonitorContentScale)(((void*)(monitor)), ((void*)(SPECIAL_VAR3)), ((void*)(SPECIAL_VAR4)));
                    Console.WriteLine("PostLoad GetMonitorContentScale");
                    Console.WriteLine("End GetMonitorContentScale");
                }
        }

        // ReSharper enable IdentifierTypo
        /// <summary>
        /// <para>
        /// This function returns a human-readable name, encoded as UTF-8, of the specified monitor.
        /// The name typically reflects the make and model of the monitor
        /// and is not guaranteed to be unique among the connected monitors.
        /// </para>
        /// </summary>
        /// <param name = "monitor">The monitor to query.</param>
        /// <returns>The UTF-8 encoded name of the monitor, or <c>null</c> if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// The returned string is allocated and freed by GLFW. You should not free it yourself.
        /// It is valid until the specified monitor is disconnected or the library is terminated.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial string GetMonitorName(global::Silk.NET.GLFW.Monitor* monitor)
        {
            void* n4;
            Console.WriteLine("Begin GetMonitorName");
            Console.WriteLine("PostInit GetMonitorName");
            Console.WriteLine("PreLoad GetMonitorName");
            n4 = ((delegate* unmanaged[Cdecl]<void*, void*> )(CurrentVTable as GeneratedVTable).glfwGetMonitorName)(((void*)(monitor)));
            Console.WriteLine("PostLoad GetMonitorName");
            Console.WriteLine("End GetMonitorName");
            return (Silk.NET.Core.Native.SilkMarshal.PtrToString((global::System.IntPtr)((byte*)n4), (Silk.NET.Core.Native.NativeStringEncoding)20));
        }

        /// <summary>
        /// <para>
        /// This function sets the user-defined pointer of the specified monitor.
        /// The current value is retained until the monitor is disconnected.
        /// The initial value is <see cref = "IntPtr.Zero"/>.
        /// </para>
        /// <para>
        /// This function may be called from the monitor callback, even for a monitor that is being disconnected.
        /// </para>
        /// </summary>
        /// <param name = "monitor">The monitor whose pointer to set.</param>
        /// <param name = "pointer">The new value.</param>
        /// <remarks>
        /// <para>
        /// This function may be called from any thread. Access is not synchronized.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void SetMonitorUserPointer(global::Silk.NET.GLFW.Monitor* monitor, nint pointer)
        {
            Console.WriteLine("Begin SetMonitorUserPointer");
            Console.WriteLine("PostInit SetMonitorUserPointer");
            Console.WriteLine("PreLoad SetMonitorUserPointer");
            ((delegate* unmanaged[Cdecl]<void*, nint, void> )(CurrentVTable as GeneratedVTable).glfwSetMonitorUserPointer)(((void*)(monitor)), (pointer));
            Console.WriteLine("PostLoad SetMonitorUserPointer");
            Console.WriteLine("End SetMonitorUserPointer");
        }

        /// <summary>
        /// <para>
        /// This function returns the current value of the user-defined pointer of the specified monitor.
        /// The initial value is <see cref = "IntPtr.Zero"/>.
        /// </para>
        /// <para>
        /// This function may be called from the monitor callback, even for a monitor that is being disconnected.
        /// </para>
        /// </summary>
        /// <param name = "monitor">The monitor whose pointer to return.</param>
        /// <returns>The user-defined pointer of the given <paramref name = "monitor"/>.</returns>
        /// <remarks>
        /// <para>
        /// This function may be called from any thread. Access is not synchronized.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial nint GetMonitorUserPointer(global::Silk.NET.GLFW.Monitor* monitor)
        {
            nint n2;
            Console.WriteLine("Begin GetMonitorUserPointer");
            Console.WriteLine("PostInit GetMonitorUserPointer");
            Console.WriteLine("PreLoad GetMonitorUserPointer");
            n2 = ((delegate* unmanaged[Cdecl]<void*, nint> )(CurrentVTable as GeneratedVTable).glfwGetMonitorUserPointer)(((void*)(monitor)));
            Console.WriteLine("PostLoad GetMonitorUserPointer");
            Console.WriteLine("End GetMonitorUserPointer");
            return n2;
        }

        /// <summary>
        /// <para>
        /// This function returns an array of all video modes supported by the specified monitor.
        /// The returned array is sorted in ascending order, first by color bit depth (the sum of all channel depths)
        /// and then by resolution area (the product of width and height).
        /// </para>
        /// </summary>
        /// <param name = "monitor">The monitor to query.</param>
        /// <param name = "count">
        /// Where to store the number of video modes in the returned array.
        /// This is set to zero if an error occurred.
        /// </param>
        /// <returns>An array of video modes, or <c>null</c> if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// The returned array is allocated and freed by GLFW. You should not free it yourself.
        /// It is valid until the specified monitor is disconnected,
        /// this function is called again for that monitor, or the library is terminated.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "GetVideoMode"/>
        public unsafe partial global::Silk.NET.GLFW.VideoMode* GetVideoModes(global::Silk.NET.GLFW.Monitor* monitor, out int count)
        {
            void* n6;
            Console.WriteLine("Begin GetVideoModes");
            fixed (int* SPECIAL_VAR2 = &count)
            {
                Console.WriteLine("PostInit GetVideoModes");
                Console.WriteLine("PreLoad GetVideoModes");
                n6 = ((delegate* unmanaged[Cdecl]<void*, void*, void*> )(CurrentVTable as GeneratedVTable).glfwGetVideoModes)(((void*)(monitor)), ((void*)(SPECIAL_VAR2)));
                Console.WriteLine("PostLoad GetVideoModes");
                Console.WriteLine("End GetVideoModes");
                return ((Silk.NET.GLFW.VideoMode*)n6);
            }
        }

        /// <summary>
        /// <para>
        /// This function generates a 256-element gamma ramp from the specified exponent and then calls
        /// <see cref = "SetGammaRamp"/> with it. The value must be a finite number greater than zero.
        /// </para>
        /// </summary>
        /// <param name = "monitor">The monitor whose gamma ramp to set.</param>
        /// <param name = "gamma">The desired exponent.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidValue"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void SetGamma(global::Silk.NET.GLFW.Monitor* monitor, float gamma)
        {
            Console.WriteLine("Begin SetGamma");
            Console.WriteLine("PostInit SetGamma");
            Console.WriteLine("PreLoad SetGamma");
            ((delegate* unmanaged[Cdecl]<void*, float, void> )(CurrentVTable as GeneratedVTable).glfwSetGamma)(((void*)(monitor)), (gamma));
            Console.WriteLine("PostLoad SetGamma");
            Console.WriteLine("End SetGamma");
        }

        /// <summary>
        /// <para>
        /// This function returns the current gamma ramp of the specified monitor.
        /// </para>
        /// </summary>
        /// <param name = "monitor">The monitor to query.</param>
        /// <returns>The current gamma ramp, or <c>null</c> if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// The returned structure and its arrays are allocated and freed by GLFW.
        /// You should not free them yourself. They are valid until the specified monitor is disconnected,
        /// this function is called again for that monitor or the library is terminated.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GammaRamp* GetGammaRamp(global::Silk.NET.GLFW.Monitor* monitor)
        {
            void* n3;
            Console.WriteLine("Begin GetGammaRamp");
            Console.WriteLine("PostInit GetGammaRamp");
            Console.WriteLine("PreLoad GetGammaRamp");
            n3 = ((delegate* unmanaged[Cdecl]<void*, void*> )(CurrentVTable as GeneratedVTable).glfwGetGammaRamp)(((void*)(monitor)));
            Console.WriteLine("PostLoad GetGammaRamp");
            Console.WriteLine("End GetGammaRamp");
            return ((Silk.NET.GLFW.GammaRamp*)n3);
        }

        /// <summary>
        /// <para>
        /// This function sets the current gamma ramp for the specified monitor.
        /// </para>
        /// <para>
        /// The original gamma ramp for that monitor
        /// is saved by GLFW the first time this function is called and is restored by <see cref = "Terminate"/>.
        /// </para>
        /// </summary>
        /// <param name = "monitor">The monitor whose gamma ramp to set.</param>
        /// <param name = "ramp">The gamma ramp to use.</param>
        /// <remarks>
        /// <para>
        /// Gamma ramp sizes other than 256 are not supported by all platforms or graphics hardware.
        /// </para>
        /// <para>
        /// Windows: The gamma ramp size must be 256.
        /// </para>
        /// <para>
        /// The specified gamma ramp is copied before this function returns.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void SetGammaRamp(global::Silk.NET.GLFW.Monitor* monitor, ref global::Silk.NET.GLFW.GammaRamp ramp)
        {
            Console.WriteLine("Begin SetGammaRamp");
            Console.WriteLine("PostInit SetGammaRamp");
            fixed (global::Silk.NET.GLFW.GammaRamp* SPECIAL_VAR2 = &ramp)
            {
                Console.WriteLine("PreLoad SetGammaRamp");
                ((delegate* unmanaged[Cdecl]<void*, void*, void> )(CurrentVTable as GeneratedVTable).glfwSetGammaRamp)(((void*)(monitor)), ((void*)(SPECIAL_VAR2)));
                Console.WriteLine("PostLoad SetGammaRamp");
                Console.WriteLine("End SetGammaRamp");
            }
        }

        /// <summary>
        /// <para>
        /// This function resets all window hints to their default values.
        /// </para>
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// </remarks>
        public partial void DefaultWindowHints()
        {
            unsafe
            {
                Console.WriteLine("Begin DefaultWindowHints");
                Console.WriteLine("PostInit DefaultWindowHints");
                Console.WriteLine("PreLoad DefaultWindowHints");
                ((delegate* unmanaged[Cdecl]<void> )(CurrentVTable as GeneratedVTable).glfwDefaultWindowHints)();
                Console.WriteLine("PostLoad DefaultWindowHints");
                Console.WriteLine("End DefaultWindowHints");
            }
        }

        /// <summary>
        /// <para>
        /// Sets the specified window hint to the desired value.
        /// </para>
        /// <para>
        /// This function sets hints for the next call to @ref glfwCreateWindow.  The
        /// hints, once set, retain their values until changed by a call to this
        /// function or <see cref = "DefaultWindowHints"/>, or until the library is terminated.
        /// </para>
        /// <para>
        /// This function does not check whether the specified hint values are valid.
        /// If you set hints to invalid values this will instead be reported by the next
        /// call to <see cref = "CreateWindow"/>.
        /// </para>
        /// <para>
        /// Some hints are platform specific.  These may be set on any platform but they
        /// will only affect their specific platform.  Other platforms will ignore them.
        /// Setting these hints requires no platform specific headers or functions.
        /// </para>
        /// </summary>
        /// <param name = "hint">The window hint to set.</param>
        /// <param name = "value">The new value of the set hint.</param>
        /// <remarks>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> <see cref = "ErrorCode.InvalidEnum"/>.
        /// </para>
        /// <para>
        /// The string is copied before this function returns.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// </remarks>
        public partial void WindowHintString(int hint, string value)
        {
            unsafe
            {
                byte* n2;
                Console.WriteLine("Begin WindowHintString");
                Console.WriteLine("PostInit WindowHintString");
                Console.WriteLine("PreLoad WindowHintString");
                n2 = (byte*)Silk.NET.Core.Native.SilkMarshal.StringToPtr((value), (Silk.NET.Core.Native.NativeStringEncoding)20);
                ((delegate* unmanaged[Cdecl]<int, void*, void> )(CurrentVTable as GeneratedVTable).glfwWindowHintString)((hint), ((void*)(n2)));
                Console.WriteLine("PostLoad WindowHintString");
                value = Silk.NET.Core.Native.SilkMarshal.PtrToString((global::System.IntPtr)(void*)(n2), (Silk.NET.Core.Native.NativeStringEncoding)20);
                Silk.NET.Core.Native.SilkMarshal.FreeString((global::System.IntPtr)n2, (Silk.NET.Core.Native.NativeStringEncoding)20);
                Console.WriteLine("End WindowHintString");
            }
        }

        /// <summary>
        /// <para>
        /// This function sets the size limits of the client area of the specified window.
        /// </para>
        /// <para>
        /// If the window is full screen, the size limits only take effect once it is made windowed.
        /// </para>
        /// <para>
        /// If the window is not resizable, this function does nothing.
        /// </para>
        /// <para>
        /// The size limits are applied immediately to a windowed mode window and may cause it to be resized.
        /// </para>
        /// <para>
        /// The maximum dimensions must be greater than or equal to the minimum dimensions
        /// and all must be greater than or equal to zero.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to set limits for.</param>
        /// <param name = "minwidth">
        /// The minimum width, in screen coordinates, of the client area, or <see cref = "Glfw.DontCare"/>.
        /// </param>
        /// <param name = "minheight">
        /// The minimum height, in screen coordinates, of the client area, or <see cref = "Glfw.DontCare"/>.
        /// </param>
        /// <param name = "maxwidth">
        /// The maximum width, in screen coordinates, of the client area, or <see cref = "Glfw.DontCare"/>.
        /// </param>
        /// <param name = "maxheight">
        /// The maximum height, in screen coordinates, of the client area, or <see cref = "Glfw.DontCare"/>.
        /// </param>
        /// <remarks>
        /// <para>
        /// If you set size limits and an aspect ratio that conflict, the results are undefined.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidValue"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void SetWindowSizeLimits(global::Silk.NET.GLFW.WindowHandle* window, int minwidth, int minheight, int maxwidth, int maxheight)
        {
            Console.WriteLine("Begin SetWindowSizeLimits");
            Console.WriteLine("PostInit SetWindowSizeLimits");
            Console.WriteLine("PreLoad SetWindowSizeLimits");
            ((delegate* unmanaged[Cdecl]<void*, int, int, int, int, void> )(CurrentVTable as GeneratedVTable).glfwSetWindowSizeLimits)(((void*)(window)), (minwidth), (minheight), (maxwidth), (maxheight));
            Console.WriteLine("PostLoad SetWindowSizeLimits");
            Console.WriteLine("End SetWindowSizeLimits");
        }

        /// <summary>
        /// <para>
        /// This function sets the required aspect ratio of the client area of the specified window.
        /// </para>
        /// <para>
        /// If the window is full screen, the aspect ratio only takes effect once it is made windowed.
        /// </para>
        /// <para>
        /// If the window is not resizable, this function does nothing.
        /// </para>
        /// <para>
        /// The aspect ratio is specified as a numerator and a denominator and both values must be greater than zero.
        /// For example, the common 16:9 aspect ratio is specified as 16 and 9, respectively.
        /// </para>
        /// <para>
        /// If the numerator and denominator is set to <see cref = "Glfw.DontCare"/> then the aspect ratio limit is disabled.
        /// </para>
        /// <para>
        /// The aspect ratio is applied immediately to a windowed mode window and may cause it to be resized.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to set limits for.</param>
        /// <param name = "numer">The numerator of the desired aspect ratio, or <see cref = "Glfw.DontCare"/>.</param>
        /// <param name = "denom">The denominator of the desired aspect ratio, or <see cref = "Glfw.DontCare"/>.</param>
        /// <remarks>
        /// <para>
        /// If you set size limits and an aspect ratio that conflict, the results are undefined.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidValue"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void SetWindowAspectRatio(global::Silk.NET.GLFW.WindowHandle* window, int numer, int denom)
        {
            Console.WriteLine("Begin SetWindowAspectRatio");
            Console.WriteLine("PostInit SetWindowAspectRatio");
            Console.WriteLine("PreLoad SetWindowAspectRatio");
            ((delegate* unmanaged[Cdecl]<void*, int, int, void> )(CurrentVTable as GeneratedVTable).glfwSetWindowAspectRatio)(((void*)(window)), (numer), (denom));
            Console.WriteLine("PostLoad SetWindowAspectRatio");
            Console.WriteLine("End SetWindowAspectRatio");
        }

        /// <summary>
        /// <para>
        /// This function retrieves the size, in screen coordinates, of each edge of the frame of the specified window.
        /// </para>
        /// <para>
        /// This size includes the title bar, if the window has one.
        /// The size of the frame may vary depending on the window-related hints used to create it.
        /// </para>
        /// <para>
        /// Because this function retrieves the size of each window frame edge
        /// and not the offset along a particular coordinate axis, the retrieved values will always be zero or positive.
        /// </para>
        /// <para>
        /// Any or all of the size arguments may be <c>out _</c>.
        /// If an error occurs, all non-<c>out _</c> size arguments will be set to zero.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose frame size to query.</param>
        /// <param name = "left">
        /// Where to store the size, in screen coordinates, of the left edge of the window frame, or <c>out _</c>.
        /// </param>
        /// <param name = "top">
        /// Where to store the size, in screen coordinates, of the top edge of the window frame, or <c>out _</c>.
        /// </param>
        /// <param name = "right">
        /// Where to store the size, in screen coordinates, of the right edge of the window frame, or <c>out _</c>.
        /// </param>
        /// <param name = "bottom">
        /// Where to store the size, in screen coordinates, of the bottom edge of the window frame, or <c>out _</c>.
        /// </param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void GetWindowFrameSize(global::Silk.NET.GLFW.WindowHandle* window, out int left, out int top, out int right, out int bottom)
        {
            Console.WriteLine("Begin GetWindowFrameSize");
            Console.WriteLine("PostInit GetWindowFrameSize");
            fixed (int* SPECIAL_VAR5 = &left)
                fixed (int* SPECIAL_VAR6 = &top)
                    fixed (int* SPECIAL_VAR7 = &right)
                        fixed (int* SPECIAL_VAR8 = &bottom)
                        {
                            Console.WriteLine("PreLoad GetWindowFrameSize");
                            ((delegate* unmanaged[Cdecl]<void*, void*, void*, void*, void*, void> )(CurrentVTable as GeneratedVTable).glfwGetWindowFrameSize)(((void*)(window)), ((void*)(SPECIAL_VAR5)), ((void*)(SPECIAL_VAR6)), ((void*)(SPECIAL_VAR7)), ((void*)(SPECIAL_VAR8)));
                            Console.WriteLine("PostLoad GetWindowFrameSize");
                            Console.WriteLine("End GetWindowFrameSize");
                        }
        }

        /// <summary>
        /// <para>
        /// This function returns the opacity of the window, including any decorations.
        /// </para>
        /// <para>
        /// The opacity (or alpha) value is a positive finite number between zero and one,
        /// where zero is fully transparent and one is fully opaque.
        /// </para>
        /// <para>
        /// If the system does not support whole window transparency, this function always returns one.
        /// </para>
        /// <para>
        /// The initial opacity value for newly created windows is one.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to query.</param>
        /// <returns>The opacity value of the specified window.</returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "SetWindowOpacity"/>
        public unsafe partial float GetWindowOpacity(global::Silk.NET.GLFW.WindowHandle* window)
        {
            float n2;
            Console.WriteLine("Begin GetWindowOpacity");
            Console.WriteLine("PostInit GetWindowOpacity");
            Console.WriteLine("PreLoad GetWindowOpacity");
            n2 = ((delegate* unmanaged[Cdecl]<void*, float> )(CurrentVTable as GeneratedVTable).glfwGetWindowOpacity)(((void*)(window)));
            Console.WriteLine("PostLoad GetWindowOpacity");
            Console.WriteLine("End GetWindowOpacity");
            return n2;
        }

        /// <summary>
        /// <para>
        /// This function sets the opacity of the window, including any decorations.
        /// </para>
        /// <para>
        /// The opacity (or alpha) value is a positive finite number between zero and one,
        /// where zero is fully transparent and one is fully opaque.
        /// </para>
        /// <para>
        /// The initial opacity value for newly created windows is one.
        /// </para>
        /// <para>
        /// A window created with framebuffer transparency may not use whole window transparency.
        /// The results of doing this are undefined.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to set the opacity for.</param>
        /// <param name = "opacity">The desired opacity of the specified window.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "GetWindowOpacity"/>
        public unsafe partial void SetWindowOpacity(global::Silk.NET.GLFW.WindowHandle* window, float opacity)
        {
            Console.WriteLine("Begin SetWindowOpacity");
            Console.WriteLine("PostInit SetWindowOpacity");
            Console.WriteLine("PreLoad SetWindowOpacity");
            ((delegate* unmanaged[Cdecl]<void*, float, void> )(CurrentVTable as GeneratedVTable).glfwSetWindowOpacity)(((void*)(window)), (opacity));
            Console.WriteLine("PostLoad SetWindowOpacity");
            Console.WriteLine("End SetWindowOpacity");
        }

        /// <summary>
        /// <para>
        /// This function requests user attention to the specified window.
        /// On platforms where this is not supported, attention is requested to the application as a whole.
        /// </para>
        /// <para>
        /// Once the user has given attention, usually by focusing the window or application,
        /// the system will end the request automatically.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to request attention to.</param>
        /// <remarks>
        /// <para>
        /// macOS: Attention is requested to the application as a whole, not the specific window.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void RequestWindowAttention(global::Silk.NET.GLFW.WindowHandle* window)
        {
            Console.WriteLine("Begin RequestWindowAttention");
            Console.WriteLine("PostInit RequestWindowAttention");
            Console.WriteLine("PreLoad RequestWindowAttention");
            ((delegate* unmanaged[Cdecl]<void*, void> )(CurrentVTable as GeneratedVTable).glfwRequestWindowAttention)(((void*)(window)));
            Console.WriteLine("PostLoad RequestWindowAttention");
            Console.WriteLine("End RequestWindowAttention");
        }

        /// <summary>
        /// <para>
        /// This function sets the value of an attribute of the specified window.
        /// </para>
        /// <para>
        /// The supported attributes are <see cref = "WindowAttributeSetter.Decorated"/>,
        /// <see cref = "WindowAttributeSetter.Resizable"/>, <see cref = "WindowAttributeSetter.Floating"/>,
        /// <see cref = "WindowAttributeSetter.AutoIconify"/> and <see cref = "WindowAttributeSetter.FocusOnShow"/>.
        /// </para>
        /// <para>
        /// Some of these attributes are ignored for full screen windows.
        /// The new value will take effect if the window is later made windowed.
        /// </para>
        /// <para>
        /// Some of these attributes are ignored for windowed mode windows.
        /// The new value will take effect if the window is later made full screen.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to set the attribute for.</param>
        /// <param name = "attrib">A supported window attribute.</param>
        /// <param name = "value"><c>true</c> or <c>false</c>.</param>
        /// <remarks>
        /// <para>
        /// Calling <see cref = "GetWindowAttrib"/> will always return the latest value,
        /// even if that value is ignored by the current mode of the window.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidEnum"/>,
        /// <see cref = "ErrorCode.InvalidValue"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void SetWindowAttrib(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.WindowAttributeSetter attrib, bool value)
        {
            Console.WriteLine("Begin SetWindowAttrib");
            Console.WriteLine("PostInit SetWindowAttrib");
            Console.WriteLine("PreLoad SetWindowAttrib");
            ((delegate* unmanaged[Cdecl]<void*, int, byte, void> )(CurrentVTable as GeneratedVTable).glfwSetWindowAttrib)(((void*)(window)), ((int)(attrib)), ((value) ? (byte)1 : (byte)0));
            Console.WriteLine("PostLoad SetWindowAttrib");
            Console.WriteLine("End SetWindowAttrib");
        }

        /// <summary>
        /// <para>
        /// This function returns whether raw mouse motion is supported on the current system.
        /// This status does not change after GLFW has been initialized so you only need to check this once.
        /// If you attempt to enable raw motion on a system that does not support it,
        /// <see cref = "ErrorCode.PlatformError"/> will be emitted.
        /// </para>
        /// <para>
        /// Raw mouse motion is closer to the actual motion of the mouse across a surface.
        /// It is not affected by the scaling and acceleration applied to the motion of the desktop cursor.
        /// That processing is suitable for a cursor while raw motion is better for controlling for example a 3D camera.
        /// Because of this, raw mouse motion is only provided when the cursor is disabled.
        /// </para>
        /// </summary>
        /// <returns>
        /// <c>true</c> if raw mouse motion is supported on the current machine, or <c>false</c> otherwise.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public partial bool RawMouseMotionSupported()
        {
            unsafe
            {
                byte n1;
                Console.WriteLine("Begin RawMouseMotionSupported");
                Console.WriteLine("PostInit RawMouseMotionSupported");
                Console.WriteLine("PreLoad RawMouseMotionSupported");
                n1 = ((delegate* unmanaged[Cdecl]<byte> )(CurrentVTable as GeneratedVTable).glfwRawMouseMotionSupported)();
                Console.WriteLine("PostLoad RawMouseMotionSupported");
                Console.WriteLine("End RawMouseMotionSupported");
                return (n1 >= 1);
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the name of the specified printable key, encoded as UTF-8.
        /// This is typically the character that key would produce without any modifier keys,
        /// intended for displaying key bindings to the user.
        /// </para>
        /// <para>
        /// For dead keys, it is typically the diacritic it would add to a character.
        /// </para>
        /// <para>
        /// Do not use this function for text input.
        /// You will break text input for many languages even if it happens to work for yours.
        /// </para>
        /// <para>
        /// If the key is <see cref = "Keys.Unknown"/>, the scancode is used to identify the key, otherwise the scancode is ignored.
        /// If you specify a non-printable key, or <see cref = "Keys.Unknown"/> and a scancode that maps to a non-printable key,
        /// this function returns <c>null</c> but does not emit an error.
        /// </para>
        /// <para>
        /// This behavior allows you to always pass in the arguments in the key callback without modification.
        /// </para>
        /// <para>
        /// The printable keys are:
        /// <list type="">
        /// <item>
        /// <term>
        /// <see cref = "Keys.Apostrophe"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.Comma"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.Minus"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.Period"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.Slash"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.Semicolon"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.Equal"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.LeftBracket"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.RightBracket"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.BackSlash"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.World1"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.World2"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term><see cref = "Keys.Number0"/> to <see cref = "Keys.Number9"/></term>
        /// </item>
        /// <item>
        /// <term><see cref = "Keys.A"/> to <see cref = "Keys.Z"/></term>
        /// </item>
        /// <item>
        /// <term><see cref = "Keys.Keypad0"/> to <see cref = "Keys.Keypad9"/></term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.KeypadDecimal"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.KeypadDivide"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.KeypadMultiply"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.KeypadSubtract"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.KeypadAdd"/>
        /// </term>
        /// </item>
        /// <item>
        /// <term>
        /// <see cref = "Keys.KeypadEqual"/>
        /// </term>
        /// </item>
        /// </list>
        /// </para>
        /// <para>
        /// Names for printable keys depend on keyboard layout,
        /// while names for non-printable keys are the same across layouts but depend on the application language
        /// and should be localized along with other user interface text.
        /// </para>
        /// </summary>
        /// <param name = "key">The key to query, or <see cref = "Keys.Unknown"/>.</param>
        /// <param name = "scancode">The scancode of the key to query.</param>
        /// <returns>The UTF-8 encoded, layout-specific name of the key, or <c>null</c>.</returns>
        /// <remarks>
        /// <para>
        /// The returned string is allocated and freed by GLFW. You should not free it yourself.
        /// It is valid until the next call to <see cref = "GetKeyName"/>, or until the library is terminated.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public partial string GetKeyName(int key, int scancode)
        {
            unsafe
            {
                void* n4;
                Console.WriteLine("Begin GetKeyName");
                Console.WriteLine("PostInit GetKeyName");
                Console.WriteLine("PreLoad GetKeyName");
                n4 = ((delegate* unmanaged[Cdecl]<int, int, void*> )(CurrentVTable as GeneratedVTable).glfwGetKeyName)((key), (scancode));
                Console.WriteLine("PostLoad GetKeyName");
                Console.WriteLine("End GetKeyName");
                return (Silk.NET.Core.Native.SilkMarshal.PtrToString((global::System.IntPtr)((byte*)n4), (Silk.NET.Core.Native.NativeStringEncoding)20));
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the platform-specific scancode of the specified key.
        /// </para>
        /// <para>
        /// If the key is <see cref = "Keys.Unknown"/> or does not exist on the keyboard this method will return -1.
        /// </para>
        /// </summary>
        /// <param name = "key">Any named key.</param>
        /// <returns>The platform-specific scancode for the key, or -1 if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidEnum"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public partial int GetKeyScancode(int key)
        {
            unsafe
            {
                int n1;
                Console.WriteLine("Begin GetKeyScancode");
                Console.WriteLine("PostInit GetKeyScancode");
                Console.WriteLine("PreLoad GetKeyScancode");
                n1 = ((delegate* unmanaged[Cdecl]<int, int> )(CurrentVTable as GeneratedVTable).glfwGetKeyScancode)((key));
                Console.WriteLine("PostLoad GetKeyScancode");
                Console.WriteLine("End GetKeyScancode");
                return n1;
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the last state reported for the specified key to the specified window.
        /// The returned state is one of <see cref = "InputAction.Press"/> or <see cref = "InputAction.Release"/>.
        /// The higher-level action <see cref = "InputAction.Repeat"/> is only reported to the key callback.
        /// </para>
        /// <para>
        /// If the <see cref = "StickyAttributes.StickyKeys"/> input mode is enabled, this function returns
        /// <see cref = "InputAction.Press"/> the first time you call it for a key that was pressed,
        /// even if that key has already been released.
        /// </para>
        /// <para>
        /// The key functions deal with physical keys,
        /// with key tokens named after their use on the standard US keyboard layout.
        /// If you want to input text, use the Unicode character callback instead.
        /// </para>
        /// <para>
        /// The modifier key bit masks are not key tokens and cannot be used with this function.
        /// </para>
        /// <para>
        /// Do not use this function to implement text input.
        /// </para>
        /// </summary>
        /// <param name = "window">The desired window.</param>
        /// <param name = "key">
        /// The desired keyboard key. <see cref = "Keys.Unknown"/> is not a valid key for this function.
        /// </param>
        /// <returns>One of <see cref = "InputAction.Press"/> or <see cref = "InputAction.Release"/>.</returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidEnum"/>.
        /// </para>
        /// </remarks>
        public unsafe partial int GetKey(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.Keys key)
        {
            int n4;
            Console.WriteLine("Begin GetKey");
            Console.WriteLine("PostInit GetKey");
            Console.WriteLine("PreLoad GetKey");
            n4 = ((delegate* unmanaged[Cdecl]<void*, int, int> )(CurrentVTable as GeneratedVTable).glfwGetKey)(((void*)(window)), ((int)(key)));
            Console.WriteLine("PostLoad GetKey");
            Console.WriteLine("End GetKey");
            return n4;
        }

        /// <summary>
        /// <para>
        /// This function returns the last state reported for the specified mouse button to the specified window.
        /// The returned state is one of <see cref = "InputAction.Press"/> or <see cref = "InputAction.Release"/>.
        /// </para>
        /// <para>
        /// If the <see cref = "StickyAttributes.StickyMouseButtons"/> input mode is enabled, this function returns
        /// <see cref = "InputAction.Press"/> the first time you call it for a mouse button that was pressed,
        /// even if that mouse button has already been released.
        /// </para>
        /// </summary>
        /// <param name = "window">The desired window.</param>
        /// <param name = "button">The desired mouse button.</param>
        /// <returns>One of <see cref = "InputAction.Press"/> or <see cref = "InputAction.Release"/>.</returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidEnum"/>.
        /// </para>
        /// </remarks>
        public unsafe partial int GetMouseButton(global::Silk.NET.GLFW.WindowHandle* window, int button)
        {
            int n3;
            Console.WriteLine("Begin GetMouseButton");
            Console.WriteLine("PostInit GetMouseButton");
            Console.WriteLine("PreLoad GetMouseButton");
            n3 = ((delegate* unmanaged[Cdecl]<void*, int, int> )(CurrentVTable as GeneratedVTable).glfwGetMouseButton)(((void*)(window)), (button));
            Console.WriteLine("PostLoad GetMouseButton");
            Console.WriteLine("End GetMouseButton");
            return n3;
        }

        /// <summary>
        /// <para>
        /// This function returns the position of the cursor,
        /// in screen coordinates, relative to the upper-left corner of the client area of the specified window.
        /// </para>
        /// <para>
        /// If the cursor is disabled (with <see cref = "CursorModeValue.CursorDisabled"/>) then the cursor position
        /// is unbounded and limited only by the minimum and maximum values of a double.
        /// </para>
        /// <para>
        /// The coordinate can be converted to their integer equivalents with the floor function.
        /// Casting directly to an integer type works for positive coordinates, but fails for negative ones.
        /// </para>
        /// <para>
        /// Any or all of the position arguments may be <c>out _</c>.
        /// If an error occurs, all non-<c>out _</c> position arguments will be set to zero.
        /// </para>
        /// </summary>
        /// <param name = "window">The desired window.</param>
        /// <param name = "xpos">
        /// Where to store the cursor x-coordinate, relative to the left edge of the client area, or <c>out _</c>.
        /// </param>
        /// <param name = "ypos">
        /// Where to store the cursor y-coordinate, relative to the to top edge of the client area, or <c>out _</c>.
        /// </param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void GetCursorPos(global::Silk.NET.GLFW.WindowHandle* window, out double xpos, out double ypos)
        {
            Console.WriteLine("Begin GetCursorPos");
            Console.WriteLine("PostInit GetCursorPos");
            fixed (double* SPECIAL_VAR3 = &xpos)
                fixed (double* SPECIAL_VAR4 = &ypos)
                {
                    Console.WriteLine("PreLoad GetCursorPos");
                    ((delegate* unmanaged[Cdecl]<void*, void*, void*, void> )(CurrentVTable as GeneratedVTable).glfwGetCursorPos)(((void*)(window)), ((void*)(SPECIAL_VAR3)), ((void*)(SPECIAL_VAR4)));
                    Console.WriteLine("PostLoad GetCursorPos");
                    Console.WriteLine("End GetCursorPos");
                }
        }

        /// <summary>
        /// <para>
        /// This function sets the position, in screen coordinates,
        /// of the cursor relative to the upper-left corner of the client area of the specified window.
        /// </para>
        /// <para>
        /// The window must have input focus.
        /// If the window does not have input focus when this function is called, it fails silently.
        /// </para>
        /// <para>
        /// Do not use this function to implement things like camera controls.
        /// GLFW already provides the <see cref = "CursorModeValue.CursorDisabled"/> cursor mode that hides the cursor,
        /// transparently re-centers it and provides unconstrained cursor motion.
        /// See <see cref = "SetInputMode(WindowHandle*, CursorStateAttribute, CursorModeValue)"/> for more information.
        /// </para>
        /// <para>
        /// If the cursor mode is <see cref = "CursorModeValue.CursorDisabled"/> then the cursor position is unconstrained
        /// and limited only by the minimum and maximum values of a double.
        /// </para>
        /// </summary>
        /// <param name = "window">The desired window.</param>
        /// <param name = "xpos">The desired x-coordinate, relative to the left edge of the client area.</param>
        /// <param name = "ypos">The desired y-coordinate, relative to the top edge of the client area.</param>
        /// <remarks>
        /// <para>
        /// Wayland: This function will only work when the cursor mode is <see cref = "CursorModeValue.CursorDisabled"/>,
        ///          otherwise it will do nothing.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
         // ReSharper disable IdentifierTypo
        public unsafe partial void SetCursorPos(global::Silk.NET.GLFW.WindowHandle* window, double xpos, double ypos)
        {
            Console.WriteLine("Begin SetCursorPos");
            Console.WriteLine("PostInit SetCursorPos");
            Console.WriteLine("PreLoad SetCursorPos");
            ((delegate* unmanaged[Cdecl]<void*, double, double, void> )(CurrentVTable as GeneratedVTable).glfwSetCursorPos)(((void*)(window)), (xpos), (ypos));
            Console.WriteLine("PostLoad SetCursorPos");
            Console.WriteLine("End SetCursorPos");
        }

        // ReSharper restore IdentifierTypo
        /// <summary>
        /// <para>
        /// Creates a new custom cursor image that can be set for a window with <see cref = "SetCursor"/>.
        /// </para>
        /// <para>
        /// The cursor can be destroyed with <see cref = "DestroyCursor"/>.
        /// Any remaining cursors are destroyed by <see cref = "Terminate"/>.
        /// </para>
        /// <para>
        /// The pixels are 32-bit, little-endian, non-premultiplied RGBA,
        /// i.e. eight bits per channel with the red channel first.
        /// They are arranged canonically as packed sequential rows, starting from the top-left corner.
        /// </para>
        /// <para>
        /// The cursor hotspot is specified in pixels, relative to the upper-left corner of the cursor image.
        /// Like all other coordinate systems in GLFW, the X-axis points to the right and the Y-axis points down.
        /// </para>
        /// </summary>
        /// <param name = "image">The desired cursor image.</param>
        /// <param name = "xhot">The desired x-coordinate, in pixels, of the cursor hotspot.</param>
        /// <param name = "yhot">The desired y-coordinate, in pixels, of the cursor hotspot.</param>
        /// <returns>The handle of the created cursor, or <c>null</c> if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// The specified image data is copied before this function returns.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
         // ReSharper disable IdentifierTypo
        public unsafe partial global::Silk.NET.GLFW.Cursor* CreateCursor(global::Silk.NET.GLFW.Image* image, int xhot, int yhot)
        {
            void* n5;
            Console.WriteLine("Begin CreateCursor");
            Console.WriteLine("PostInit CreateCursor");
            Console.WriteLine("PreLoad CreateCursor");
            n5 = ((delegate* unmanaged[Cdecl]<void*, int, int, void*> )(CurrentVTable as GeneratedVTable).glfwCreateCursor)(((void*)(image)), (xhot), (yhot));
            Console.WriteLine("PostLoad CreateCursor");
            Console.WriteLine("End CreateCursor");
            return ((Silk.NET.GLFW.Cursor*)n5);
        }

        // ReSharper restore IdentifierTypo
        /// <summary>
        /// <para>
        /// Returns a cursor with a standard shape, that can be set for a window with <see cref = "SetCursor"/>.
        /// </para>
        /// </summary>
        /// <param name = "shape">One of the standard shapes.</param>
        /// <returns>A new cursor ready to use or <c>null</c> if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidEnum"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.Cursor* CreateStandardCursor(global::Silk.NET.GLFW.CursorShape shape)
        {
            void* n3;
            Console.WriteLine("Begin CreateStandardCursor");
            Console.WriteLine("PostInit CreateStandardCursor");
            Console.WriteLine("PreLoad CreateStandardCursor");
            n3 = ((delegate* unmanaged[Cdecl]<int, void*> )(CurrentVTable as GeneratedVTable).glfwCreateStandardCursor)(((int)(shape)));
            Console.WriteLine("PostLoad CreateStandardCursor");
            Console.WriteLine("End CreateStandardCursor");
            return ((Silk.NET.GLFW.Cursor*)n3);
        }

        /// <summary>
        /// <para>
        /// This function destroys a cursor previously created with <see cref = "CreateCursor"/>.
        /// Any remaining cursors will be destroyed by <see cref = "Terminate"/>.
        /// </para>
        /// <para>
        /// If the specified cursor is current for any window, that window will be reverted to the default cursor.
        /// This does not affect the cursor mode.
        /// </para>
        /// </summary>
        /// <param name = "cursor">The cursor object to destroy.</param>
        /// <remarks>
        /// <para>
        /// This function must not be called from a callback.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void DestroyCursor(global::Silk.NET.GLFW.Cursor* cursor)
        {
            Console.WriteLine("Begin DestroyCursor");
            Console.WriteLine("PostInit DestroyCursor");
            Console.WriteLine("PreLoad DestroyCursor");
            ((delegate* unmanaged[Cdecl]<void*, void> )(CurrentVTable as GeneratedVTable).glfwDestroyCursor)(((void*)(cursor)));
            Console.WriteLine("PostLoad DestroyCursor");
            Console.WriteLine("End DestroyCursor");
        }

        /// <summary>
        /// <para>
        /// This function sets the cursor image to be used when the cursor is over the client area
        /// of the specified window.
        /// </para>
        /// <para>
        /// The set cursor will only be visible
        /// when the cursor mode of the window is <see cref = "CursorModeValue.CursorNormal"/>.
        /// </para>
        /// <para>
        /// On some platforms, the set cursor may not be visible unless the window also has input focus.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to set the cursor for.</param>
        /// <param name = "cursor">The cursor to set, or <c>null</c> to switch back to the default arrow cursor.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void SetCursor(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.Cursor* cursor)
        {
            Console.WriteLine("Begin SetCursor");
            Console.WriteLine("PostInit SetCursor");
            Console.WriteLine("PreLoad SetCursor");
            ((delegate* unmanaged[Cdecl]<void*, void*, void> )(CurrentVTable as GeneratedVTable).glfwSetCursor)(((void*)(window)), ((void*)(cursor)));
            Console.WriteLine("PostLoad SetCursor");
            Console.WriteLine("End SetCursor");
        }

        /// <summary>
        /// <para>
        /// This function returns whether the specified joystick is present.
        /// </para>
        /// <para>
        /// There is no need to call this function before other functions that accept a joystick ID,
        /// as they all check for presence before performing any other work.
        /// </para>
        /// </summary>
        /// <param name = "jid">The joystick to query.</param>
        /// <returns><c>true</c> if the joystick is present, or <c>false</c> otherwise.</returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidEnum"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public partial bool JoystickPresent(int jid)
        {
            unsafe
            {
                byte n2;
                Console.WriteLine("Begin JoystickPresent");
                Console.WriteLine("PostInit JoystickPresent");
                Console.WriteLine("PreLoad JoystickPresent");
                n2 = ((delegate* unmanaged[Cdecl]<int, byte> )(CurrentVTable as GeneratedVTable).glfwJoystickPresent)((jid));
                Console.WriteLine("PostLoad JoystickPresent");
                Console.WriteLine("End JoystickPresent");
                return (n2 >= 1);
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the values of all axes of the specified joystick.
        /// Each element in the array is a value between -1.0 and 1.0.
        /// </para>
        /// <para>
        /// If the specified joystick is not present
        /// this function will return <c>null</c> but will not generate an error.
        /// This can be used instead of first calling <see cref = "JoystickPresent"/>.
        /// </para>
        /// </summary>
        /// <param name = "jid">The joystick to query.</param>
        /// <param name = "count">
        /// Where to store the number of axis values in the returned array.
        /// This is set to zero if the joystick is not present or an error occurred.
        /// </param>
        /// <returns>
        /// An array of axis values, or <c>null</c> if the joystick is not present or an error occurred.
        /// </returns>
        /// <remarks>
        /// <para>
        /// The returned array is allocated and freed by GLFW.
        /// You should not free it yourself.
        /// It is valid until the specified joystick is disconnected or the library is terminated.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidEnum"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial float* GetJoystickAxes(int jid, out int count)
        {
            void* n5;
            Console.WriteLine("Begin GetJoystickAxes");
            fixed (int* SPECIAL_VAR2 = &count)
            {
                Console.WriteLine("PostInit GetJoystickAxes");
                Console.WriteLine("PreLoad GetJoystickAxes");
                n5 = ((delegate* unmanaged[Cdecl]<int, void*, void*> )(CurrentVTable as GeneratedVTable).glfwGetJoystickAxes)((jid), ((void*)(SPECIAL_VAR2)));
                Console.WriteLine("PostLoad GetJoystickAxes");
                Console.WriteLine("End GetJoystickAxes");
                return ((float*)n5);
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the state of all buttons of the specified joystick.
        /// Each element in the array is either <see cref = "InputAction.Press"/> or <see cref = "InputAction.Release"/>.
        /// </para>
        /// <para>
        /// For backward compatibility with earlier versions that did not have <see cref = "GetJoystickHats"/>,
        /// the button array also includes all hats, each represented as four buttons.
        /// </para>
        /// <para>
        /// The hats are in the same order as returned by <see cref = "GetJoystickHats"/> and are in the order
        /// up, right, down and left.
        /// </para>
        /// <para>
        /// To disable these extra buttons, set the <see cref = "NET.GLFW.InitHint.JoystickHatButtons"/>
        /// init hint before initialization.
        /// </para>
        /// <para>
        /// If the specified joystick is not present this function will return <c>null</c> but will not generate an error.
        /// This can be used instead of first calling <see cref = "JoystickPresent"/>.
        /// </para>
        /// </summary>
        /// <param name = "jid">The joystick to query.</param>
        /// <param name = "count">
        /// Where to store the number of button states in the returned array.
        /// This is set to zero if the joystick is not present or an error occurred.
        /// </param>
        /// <returns>
        /// An array of button states, or <c>null</c> if the joystick is not present or an error occurred.
        /// </returns>
        /// <remarks>
        /// <para>
        /// The returned array is allocated and freed by GLFW. You should not free it yourself.
        /// It is valid until the specified joystick is disconnected or the library is terminated.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidEnum"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial byte* GetJoystickButtons(int jid, out int count)
        {
            void* n5;
            Console.WriteLine("Begin GetJoystickButtons");
            fixed (int* SPECIAL_VAR2 = &count)
            {
                Console.WriteLine("PostInit GetJoystickButtons");
                Console.WriteLine("PreLoad GetJoystickButtons");
                n5 = ((delegate* unmanaged[Cdecl]<int, void*, void*> )(CurrentVTable as GeneratedVTable).glfwGetJoystickButtons)((jid), ((void*)(SPECIAL_VAR2)));
                Console.WriteLine("PostLoad GetJoystickButtons");
                Console.WriteLine("End GetJoystickButtons");
                return ((byte*)n5);
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the state of all hats of the specified joystick.
        /// Each element in the array is one of the <see cref = "JoystickHats"/>.
        /// </para>
        /// <para>
        /// The diagonal directions are bitwise combinations of the primary (up, right, down and left) directions
        /// and you can test for these individually by ANDing it with the corresponding direction.
        /// <code>
        /// if (hats[2].HasFlag(JoystickHats.Right))
        /// {
        ///    // State of hat 2 could be right-up, right or right-down
        /// }
        /// </code>
        /// </para>
        /// <para>
        /// If the specified joystick is not present, this function will return NULL but will not generate an error.
        /// This can be used instead of first calling <see cref = "JoystickPresent"/>.
        /// </para>
        /// </summary>
        /// <param name = "jid">The joystick to query.</param>
        /// <param name = "count">
        /// Where to store the number of hat states in the returned array.
        /// This is set to zero if the joystick is not present or an error occurred.
        /// </param>
        /// <returns>
        /// An array of hat states, or <c>null</c> if the joystick is not present or an error occurred.
        /// </returns>
        /// <remarks>
        /// <para>
        /// The returned array is allocated and freed by GLFW. You should not free it yourself
        /// It is valid until the specified joystick is disconnected,
        /// this function is called again for that joystick or the library is terminated.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidEnum"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.JoystickHats* GetJoystickHats(int jid, out int count)
        {
            void* n5;
            Console.WriteLine("Begin GetJoystickHats");
            fixed (int* SPECIAL_VAR2 = &count)
            {
                Console.WriteLine("PostInit GetJoystickHats");
                Console.WriteLine("PreLoad GetJoystickHats");
                n5 = ((delegate* unmanaged[Cdecl]<int, void*, void*> )(CurrentVTable as GeneratedVTable).glfwGetJoystickHats)((jid), ((void*)(SPECIAL_VAR2)));
                Console.WriteLine("PostLoad GetJoystickHats");
                Console.WriteLine("End GetJoystickHats");
                return ((Silk.NET.GLFW.JoystickHats*)n5);
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the name, encoded as UTF-8, of the specified joystick.
        /// </para>
        /// <para>
        /// If the specified joystick is not present this function will return <c>null</c> but will not generate an error.
        /// This can be used instead of first calling <see cref = "JoystickPresent"/>.
        /// </para>
        /// </summary>
        /// <param name = "jid">The joystick to query.</param>
        /// <returns>
        /// The UTF-8 encoded name of the joystick, or <c>null</c> if the joystick is not present or an error occurred.
        /// </returns>
        /// <remarks>
        /// <para>
        /// The returned string is allocated and freed by GLFW. You should not free it yourself.
        /// It is valid until the specified joystick is disconnected or the library is terminated.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidEnum"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public partial string GetJoystickName(int jid)
        {
            unsafe
            {
                void* n3;
                Console.WriteLine("Begin GetJoystickName");
                Console.WriteLine("PostInit GetJoystickName");
                Console.WriteLine("PreLoad GetJoystickName");
                n3 = ((delegate* unmanaged[Cdecl]<int, void*> )(CurrentVTable as GeneratedVTable).glfwGetJoystickName)((jid));
                Console.WriteLine("PostLoad GetJoystickName");
                Console.WriteLine("End GetJoystickName");
                return (Silk.NET.Core.Native.SilkMarshal.PtrToString((global::System.IntPtr)((byte*)n3), (Silk.NET.Core.Native.NativeStringEncoding)20));
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the SDL compatible GUID, as a UTF-8 encoded hexadecimal string,
        /// of the specified joystick.
        /// The returned string is allocated and freed by GLFW. You should not free it yourself.
        /// </para>
        /// <para>
        /// The GUID is what connects a joystick to a gamepad mapping.
        /// A connected joystick will always have a GUID even if there is no gamepad mapping assigned to it.
        /// </para>
        /// <para>
        /// If the specified joystick is not present this function will return <c>null</c> but will not generate an error.
        /// This can be used instead of first calling <see cref = "JoystickPresent"/>.
        /// </para>
        /// <para>
        /// The GUID uses the format introduced in SDL 2.0.5.
        /// This GUID tries to uniquely identify the make and model of a joystick but does not identify a specific unit,
        /// e.g. all wired Xbox 360 controllers will have the same GUID on that platform.
        /// The GUID for a unit may vary between platforms
        /// depending on what hardware information the platform specific APIs provide.
        /// </para>
        /// </summary>
        /// <param name = "jid">The joystick to query.</param>
        /// <returns>
        /// The UTF-8 encoded GUID of the joystick, or <c>null</c> if the joystick is not present or an error occurred.
        /// </returns>
        /// <remarks>
        /// <para>
        /// The returned string is allocated and freed by GLFW. You should not free it yourself.
        /// It is valid until the specified joystick is disconnected or the library is terminated.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidEnum"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public partial string GetJoystickGUID(int jid)
        {
            unsafe
            {
                void* n3;
                Console.WriteLine("Begin GetJoystickGUID");
                Console.WriteLine("PostInit GetJoystickGUID");
                Console.WriteLine("PreLoad GetJoystickGUID");
                n3 = ((delegate* unmanaged[Cdecl]<int, void*> )(CurrentVTable as GeneratedVTable).glfwGetJoystickGUID)((jid));
                Console.WriteLine("PostLoad GetJoystickGUID");
                Console.WriteLine("End GetJoystickGUID");
                return (Silk.NET.Core.Native.SilkMarshal.PtrToString((global::System.IntPtr)((byte*)n3), (Silk.NET.Core.Native.NativeStringEncoding)20));
            }
        }

        /// <summary>
        /// <para>
        /// This function sets the user-defined pointer of the specified joystick.
        /// The current value is retained until the joystick is disconnected.
        /// The initial value is <see cref = "IntPtr.Zero"/>.
        /// </para>
        /// <para>
        /// This function may be called from the joystick callback, even for a joystick that is being disconnected.
        /// </para>
        /// </summary>
        /// <param name = "jid">The joystick whose pointer to set.</param>
        /// <param name = "ptr">The new value.</param>
        /// <remarks>
        /// <para>
        /// This function may be called from any thread. Access is not synchronized.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public partial void SetJoystickUserPointer(int jid, nint ptr)
        {
            unsafe
            {
                Console.WriteLine("Begin SetJoystickUserPointer");
                Console.WriteLine("PostInit SetJoystickUserPointer");
                Console.WriteLine("PreLoad SetJoystickUserPointer");
                ((delegate* unmanaged[Cdecl]<int, nint, void> )(CurrentVTable as GeneratedVTable).glfwSetJoystickUserPointer)((jid), (ptr));
                Console.WriteLine("PostLoad SetJoystickUserPointer");
                Console.WriteLine("End SetJoystickUserPointer");
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the current value of the user-defined pointer of the specified joystick.
        /// The initial value is <see cref = "IntPtr.Zero"/>.
        /// </para>
        /// <para>
        /// This function may be called from the joystick callback, even for a joystick that is being disconnected.
        /// </para>
        /// </summary>
        /// <param name = "jid">The joystick whose pointer to return.</param>
        /// <returns>The user-defined pointer of the given <paramref name = "jid"/>.</returns>
        /// <remarks>
        /// <para>
        /// This function may be called from any thread. Access is not synchronized.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public partial nint GetJoystickUserPointer(int jid)
        {
            unsafe
            {
                nint n1;
                Console.WriteLine("Begin GetJoystickUserPointer");
                Console.WriteLine("PostInit GetJoystickUserPointer");
                Console.WriteLine("PreLoad GetJoystickUserPointer");
                n1 = ((delegate* unmanaged[Cdecl]<int, nint> )(CurrentVTable as GeneratedVTable).glfwGetJoystickUserPointer)((jid));
                Console.WriteLine("PostLoad GetJoystickUserPointer");
                Console.WriteLine("End GetJoystickUserPointer");
                return n1;
            }
        }

        /// <summary>
        /// <para>
        /// This function returns whether the specified joystick is both present and has a gamepad mapping.
        /// </para>
        /// <para>
        /// If the specified joystick is present but does not have a gamepad mapping
        /// this function will return <c>false</c> but will not generate an error.
        /// </para>
        /// </summary>
        /// <param name = "jid">The joystick to query.</param>
        /// <returns>
        /// <c>true</c> if a joystick is both present and has a gamepad mapping, or <c>false</c> otherwise.
        /// </returns>
        /// <remarks>
        /// <para>
        /// Call <see cref = "JoystickPresent"/> to check if a joystick is present regardless of whether it has a mapping.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidEnum"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "GetGamepadState"/>
        public partial bool JoystickIsGamepad(int jid)
        {
            unsafe
            {
                byte n2;
                Console.WriteLine("Begin JoystickIsGamepad");
                Console.WriteLine("PostInit JoystickIsGamepad");
                Console.WriteLine("PreLoad JoystickIsGamepad");
                n2 = ((delegate* unmanaged[Cdecl]<int, byte> )(CurrentVTable as GeneratedVTable).glfwJoystickIsGamepad)((jid));
                Console.WriteLine("PostLoad JoystickIsGamepad");
                Console.WriteLine("End JoystickIsGamepad");
                return (n2 >= 1);
            }
        }

        /// <summary>
        /// <para>
        /// This function parses the specified ASCII encoded string
        /// and updates the internal list with any gamepad mappings it finds.
        /// </para>
        /// <para>
        /// This string may contain either a single gamepad mapping or many mappings separated by newlines.
        /// </para>
        /// <para>
        /// The parser supports the full format of the gamecontrollerdb.txt source file
        /// including empty lines and comments.
        /// </para>
        /// <para>
        /// See <a href="https://www.glfw.org/docs/3.3/input_guide.html#gamepad_mapping">Gamepad mappings</a>
        /// for a description of the format.
        /// </para>
        /// <para>
        /// If there is already a gamepad mapping for a given GUID in the internal list, it will be replaced by the one passed to
        /// this function. If the library is terminated and re-initialized the internal list will revert to the built-in default.
        /// </para>
        /// </summary>
        /// <param name = "newMapping">The string containing the gamepad mappings.</param>
        /// <returns><c>true</c> if successful, or <c>false</c> if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidValue"/>.
        /// </para>
        /// </remarks>
        public partial bool UpdateGamepadMappings(string newMapping)
        {
            unsafe
            {
                byte n4;
                byte* n1;
                Console.WriteLine("Begin UpdateGamepadMappings");
                Console.WriteLine("PostInit UpdateGamepadMappings");
                Console.WriteLine("PreLoad UpdateGamepadMappings");
                n1 = (byte*)Silk.NET.Core.Native.SilkMarshal.StringToPtr((newMapping), (Silk.NET.Core.Native.NativeStringEncoding)20);
                n4 = ((delegate* unmanaged[Cdecl]<void*, byte> )(CurrentVTable as GeneratedVTable).glfwUpdateGamepadMappings)(((void*)(n1)));
                Console.WriteLine("PostLoad UpdateGamepadMappings");
                newMapping = Silk.NET.Core.Native.SilkMarshal.PtrToString((global::System.IntPtr)(void*)(n1), (Silk.NET.Core.Native.NativeStringEncoding)20);
                Silk.NET.Core.Native.SilkMarshal.FreeString((global::System.IntPtr)n1, (Silk.NET.Core.Native.NativeStringEncoding)20);
                Console.WriteLine("End UpdateGamepadMappings");
                return (n4 >= 1);
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the human-readable name of the gamepad
        /// from the gamepad mapping assigned to the specified joystick.
        /// </para>
        /// <para>
        /// If the specified joystick is not present or does not have a gamepad mapping
        /// this function will return <c>null</c> but will not generate an error.
        /// </para>
        /// </summary>
        /// <param name = "jid">The joystick to query.</param>
        /// <returns>
        /// The UTF-8 encoded name of the gamepad, or <c>null</c> if the joystick is not present,
        /// does not have a mapping or an error occurred.
        /// </returns>
        /// <remarks>
        /// <para>
        /// Call <see cref = "JoystickPresent"/> to check whether it is present regardless of whether it has a mapping.
        /// </para>
        /// <para>
        /// The returned string is allocated and freed by GLFW. You should not free it yourself.
        /// It is valid until the specified joystick is disconnected,
        /// the gamepad mappings are updated or the library is terminated.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// </remarks>
        public partial string GetGamepadName(int jid)
        {
            unsafe
            {
                void* n3;
                Console.WriteLine("Begin GetGamepadName");
                Console.WriteLine("PostInit GetGamepadName");
                Console.WriteLine("PreLoad GetGamepadName");
                n3 = ((delegate* unmanaged[Cdecl]<int, void*> )(CurrentVTable as GeneratedVTable).glfwGetGamepadName)((jid));
                Console.WriteLine("PostLoad GetGamepadName");
                Console.WriteLine("End GetGamepadName");
                return (Silk.NET.Core.Native.SilkMarshal.PtrToString((global::System.IntPtr)((byte*)n3), (Silk.NET.Core.Native.NativeStringEncoding)20));
            }
        }

        /// <summary>
        /// <para>
        /// This function retrieves the state of the specified joystick remapped to an Xbox-like gamepad.
        /// </para>
        /// <para>
        /// If the specified joystick is not present or does not have a gamepad mapping
        /// this function will return <c>false</c> but will not generate an error.
        /// Call <see cref = "JoystickPresent"/> to check whether it is present regardless of whether it has a mapping.
        /// </para>
        /// <para>
        /// The Guide button may not be available for input as it is often hooked by the system or the Steam client.
        /// </para>
        /// <para>
        /// Not all devices have all the buttons or axes provided by <see cref = "GamepadState"/>.
        /// Unavailable buttons and axes will always report <see cref = "InputAction.Release"/> and 0.0 respectively.
        /// </para>
        /// </summary>
        /// <param name = "jid">The joystick to query.</param>
        /// <param name = "state">The gamepad input state of the joystick.</param>
        /// <returns>
        /// <c>true</c> if successful, or <c>false</c> if no joystick is connected,
        /// it has no gamepad mapping or an error occurred.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidEnum"/>.
        /// </para>
        /// </remarks>
        public partial bool GetGamepadState(int jid, out global::Silk.NET.GLFW.GamepadState state)
        {
            unsafe
            {
                byte n5;
                Console.WriteLine("Begin GetGamepadState");
                fixed (global::Silk.NET.GLFW.GamepadState* SPECIAL_VAR2 = &state)
                {
                    Console.WriteLine("PostInit GetGamepadState");
                    Console.WriteLine("PreLoad GetGamepadState");
                    n5 = ((delegate* unmanaged[Cdecl]<int, void*, byte> )(CurrentVTable as GeneratedVTable).glfwGetGamepadState)((jid), ((void*)(SPECIAL_VAR2)));
                    Console.WriteLine("PostLoad GetGamepadState");
                    Console.WriteLine("End GetGamepadState");
                    return (n5 >= 1);
                }
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the value of the GLFW timer.
        /// </para>
        /// <para>
        /// Unless the timer has been set using <see cref = "SetTime"/>,
        /// the timer measures time elapsed since GLFW was initialized.
        /// </para>
        /// <para>
        /// The resolution of the timer is system dependent, but is usually on the order of a few micro- or nanoseconds.
        /// It uses the highest-resolution monotonic time source on each supported platform.
        /// </para>
        /// </summary>
        /// <returns>The current value, in seconds, or zero if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// <para>
        /// Reading and writing of the internal timer offset is not atomic,
        /// so it needs to be externally synchronized with calls to <see cref = "SetTime"/>.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public partial double GetTime()
        {
            unsafe
            {
                double n0;
                Console.WriteLine("Begin GetTime");
                Console.WriteLine("PostInit GetTime");
                Console.WriteLine("PreLoad GetTime");
                n0 = ((delegate* unmanaged[Cdecl]<double> )(CurrentVTable as GeneratedVTable).glfwGetTime)();
                Console.WriteLine("PostLoad GetTime");
                Console.WriteLine("End GetTime");
                return n0;
            }
        }

        /// <summary>
        /// <para>
        /// This function sets the value of the GLFW timer. It then continues to count up from that value.
        /// The value must be a positive finite number less than or equal to 18446744073.0,
        /// which is approximately 584.5 years.
        /// </para>
        /// </summary>
        /// <param name = "time">The new value, in seconds.</param>
        /// <remarks>
        /// <para>
        /// The upper limit of the timer is calculated as floor((2^64 - 1) / 109) and is due to implementations
        /// storing nanoseconds in 64 bits. The limit may be increased in the future.
        /// </para>
        /// <para>
        /// This function may be called from any thread.
        /// Reading and writing of the internal timer offset is not atomic,
        /// so it needs to be externally synchronized with calls to <see cref = "GetTime"/>.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidValue"/>.
        /// </para>
        /// </remarks>
        public partial void SetTime(double time)
        {
            unsafe
            {
                Console.WriteLine("Begin SetTime");
                Console.WriteLine("PostInit SetTime");
                Console.WriteLine("PreLoad SetTime");
                ((delegate* unmanaged[Cdecl]<double, void> )(CurrentVTable as GeneratedVTable).glfwSetTime)((time));
                Console.WriteLine("PostLoad SetTime");
                Console.WriteLine("End SetTime");
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the current value of the raw timer, measured in 1 / frequency seconds.
        /// To get the frequency, call <see cref = "GetTimerFrequency"/>.
        /// </para>
        /// </summary>
        /// <returns>The value of the timer, or zero if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public partial long GetTimerValue()
        {
            unsafe
            {
                long n0;
                Console.WriteLine("Begin GetTimerValue");
                Console.WriteLine("PostInit GetTimerValue");
                Console.WriteLine("PreLoad GetTimerValue");
                n0 = ((delegate* unmanaged[Cdecl]<long> )(CurrentVTable as GeneratedVTable).glfwGetTimerValue)();
                Console.WriteLine("PostLoad GetTimerValue");
                Console.WriteLine("End GetTimerValue");
                return n0;
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the frequency, in Hz, of the raw timer.
        /// </para>
        /// </summary>
        /// <returns>he frequency of the timer, in Hz, or zero if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public partial long GetTimerFrequency()
        {
            unsafe
            {
                long n0;
                Console.WriteLine("Begin GetTimerFrequency");
                Console.WriteLine("PostInit GetTimerFrequency");
                Console.WriteLine("PreLoad GetTimerFrequency");
                n0 = ((delegate* unmanaged[Cdecl]<long> )(CurrentVTable as GeneratedVTable).glfwGetTimerFrequency)();
                Console.WriteLine("PostLoad GetTimerFrequency");
                Console.WriteLine("End GetTimerFrequency");
                return n0;
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the window whose OpenGL or OpenGL ES context is current on the calling thread.
        /// </para>
        /// </summary>
        /// <returns>The window whose context is current, or <c>null</c> if no window's context is current.</returns>
        /// <remarks>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.WindowHandle* GetCurrentContext()
        {
            void* n1;
            Console.WriteLine("Begin GetCurrentContext");
            Console.WriteLine("PostInit GetCurrentContext");
            Console.WriteLine("PreLoad GetCurrentContext");
            n1 = ((delegate* unmanaged[Cdecl]<void*> )(CurrentVTable as GeneratedVTable).glfwGetCurrentContext)();
            Console.WriteLine("PostLoad GetCurrentContext");
            Console.WriteLine("End GetCurrentContext");
            return ((Silk.NET.GLFW.WindowHandle*)n1);
        }

        /// <summary>
        /// <para>
        /// This function swaps the front and back buffers of the specified window
        /// when rendering with OpenGL or OpenGL ES.
        /// </para>
        /// <para>
        /// If the swap interval is greater than zero,
        /// the GPU driver waits the specified number of screen updates before swapping the buffers.
        /// </para>
        /// <para>
        /// The specified window must have an OpenGL or OpenGL ES context.
        /// Specifying a window without a context will generate a <see cref = "ErrorCode.NoWindowContext"/> error.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose buffers to swap.</param>
        /// <remarks>
        /// <para>
        /// EGL: The context of the specified window must be current on the calling thread.
        /// </para>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.NoWindowContext"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void SwapBuffers(global::Silk.NET.GLFW.WindowHandle* window)
        {
            Console.WriteLine("Begin SwapBuffers");
            Console.WriteLine("PostInit SwapBuffers");
            Console.WriteLine("PreLoad SwapBuffers");
            ((delegate* unmanaged[Cdecl]<void*, void> )(CurrentVTable as GeneratedVTable).glfwSwapBuffers)(((void*)(window)));
            Console.WriteLine("PostLoad SwapBuffers");
            Console.WriteLine("End SwapBuffers");
        }

        /// <summary>
        /// <para>
        /// This function returns whether the specified API extension is supported
        /// by the current OpenGL or OpenGL ES context.
        /// It searches both for client API extension and context creation API extensions.
        /// </para>
        /// <para>
        /// A context must be current on the calling thread.
        /// Calling this function without a current context will cause a <see cref = "ErrorCode.NoWindowContext"/> error.
        /// </para>
        /// <para>
        /// As this functions retrieves and searches one or more extension strings each call,
        /// it is recommended that you cache its results if it is going to be used frequently.
        /// The extension strings will not change during the lifetime of a context, so there is no danger in doing this.
        /// </para>
        /// </summary>
        /// <param name = "extensionName">The ASCII encoded name of the extension.</param>
        /// <returns><c>true</c> if the extension is available, or <c>false</c> otherwise.</returns>
        /// <remarks>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.NoContext"/>,
        /// <see cref = "ErrorCode.InvalidValue"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public partial bool ExtensionSupported(string extensionName)
        {
            unsafe
            {
                byte n4;
                byte* n1;
                Console.WriteLine("Begin ExtensionSupported");
                Console.WriteLine("PostInit ExtensionSupported");
                Console.WriteLine("PreLoad ExtensionSupported");
                n1 = (byte*)Silk.NET.Core.Native.SilkMarshal.StringToPtr((extensionName), (Silk.NET.Core.Native.NativeStringEncoding)20);
                n4 = ((delegate* unmanaged[Cdecl]<void*, byte> )(CurrentVTable as GeneratedVTable).glfwExtensionSupported)(((void*)(n1)));
                Console.WriteLine("PostLoad ExtensionSupported");
                extensionName = Silk.NET.Core.Native.SilkMarshal.PtrToString((global::System.IntPtr)(void*)(n1), (Silk.NET.Core.Native.NativeStringEncoding)20);
                Silk.NET.Core.Native.SilkMarshal.FreeString((global::System.IntPtr)n1, (Silk.NET.Core.Native.NativeStringEncoding)20);
                Console.WriteLine("End ExtensionSupported");
                return (n4 >= 1);
            }
        }

        /// <summary>
        /// <para>
        /// This function creates a window and its associated OpenGL or OpenGL ES context.
        /// Most of the options controlling how the window and its context should be created
        /// are specified with window hints.
        /// </para>
        /// <para>
        /// Successful creation does not change which context is current.
        /// Before you can use the newly created context, you need to make it current.
        /// For information about the share parameter, see
        /// <a href="">Context object sharing</a>.
        /// </para>
        /// <para>
        /// The created window, framebuffer and context may differ from what you requested,
        /// as not all parameters and hints are
        /// <a href="https://www.glfw.org/docs/latest/window_guide.html#window_hints_hard">hard constraints</a>.
        /// This includes the size of the window, especially for full screen windows.
        /// To query the actual attributes of the created window, framebuffer and context,
        /// see <see cref = "GetWindowAttrib"/>, <see cref = "GetWindowSize"/> and <see cref = "GetFramebufferSize"/>.
        /// </para>
        /// <para>
        /// To create a full screen window, you need to specify the monitor the window will cover.
        /// If no monitor is specified, the window will be windowed mode.
        /// Unless you have a way for the user to choose a specific monitor,
        /// it is recommended that you pick the primary monitor.
        /// For more information on how to query connected monitors, see
        /// <a href="https://www.glfw.org/docs/latest/monitor_guide.html#monitor_monitors">Retrieving monitors</a>.
        /// </para>
        /// <para>
        /// For full screen windows, the specified size becomes the resolution of the window's desired video mode.
        /// As long as a full screen window is not iconified,
        /// the supported video mode most closely matching the desired video mode is set for the specified monitor.
        /// For more information about full screen windows, including the creation of so called windowed full screen
        /// or borderless full screen windows, see
        /// <a href="https://www.glfw.org/docs/latest/window_guide.html#window_windowed_full_screen">
        /// "Windowed full screen" windows
        /// </a>
        /// .
        /// </para>
        /// <para>
        /// Once you have created the window, you can switch it between windowed and full screen mode
        /// with <see cref = "SetWindowMonitor"/>. If the window has an OpenGL or OpenGL ES context, it will be unaffected.
        /// </para>
        /// <para>
        /// By default, newly created windows use the placement recommended by the window system.
        /// To create the window at a specific position,
        /// make it initially invisible using the <see cref = "WindowHintBool.Visible"/> window hint,
        /// set its position(see <see cref = "SetWindowPos"/>) and then show it
        /// (see <see cref = "ShowWindow"/>).
        /// </para>
        /// <para>
        /// As long as at least one full screen window is not iconified, the screensaver is prohibited from starting.
        /// </para>
        /// <para>
        /// Window systems put limits on window sizes.
        /// Very large or very small window dimensions may be overridden by the window system on creation.
        /// Check the actual size after creation(see <see cref = "GetWindowSize"/> or <see cref = "SetWindowSizeCallback"/>.
        /// </para>
        /// <para>
        /// The <a href="https://www.glfw.org/docs/latest/window_guide.html#buffer_swap">swap interval</a>
        /// is not set during window creation and the initial value may vary
        /// depending on driver settings and defaults.
        /// </para>
        /// </summary>
        /// <param name = "width">
        /// The desired width, in screen coordinates, of the window. This must be greater than zero.
        /// </param>
        /// <param name = "height">
        /// The desired height, in screen coordinates, of the window. This must be greater than zero.
        /// </param>
        /// <param name = "title">The initial, UTF-8 encoded window title.</param>
        /// <param name = "monitor">The monitor to use for full screen mode, or <c>null</c> for windowed mode.</param>
        /// <param name = "share">
        /// The window whose context to share resources with, or <c>null</c> to not share resources.
        /// </param>
        /// <returns>The handle of the created window, or <c>null</c> if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// Windows: Window creation will fail if the Microsoft GDI software OpenGL implementation is the only one available.
        /// </para>
        /// <para>
        /// Windows: If the executable has an icon resource named GLFW_ICON, it will be set as the initial icon for the window.
        ///          If no such icon is present, the IDI_WINLOGO icon will be used instead. To set a different icon, see
        /// <see cref = "SetWindowIcon"/>.
        /// </para>
        /// <para>
        /// Windows: The context to share resources with must not be current on any other thread.
        /// </para>
        /// <para>
        /// OS X: The GLFW window has no icon, as it is not a document window, but the dock icon will be the same as the
        /// application bundle's icon.
        /// For more information on bundles, see the Bundle Programming Guide in the Mac Developer Library.
        /// </para>
        /// <para>
        /// OS X: The first time a window is created the menu bar is populated with common commands like Hide, Quit and About.
        ///       The About entry opens a minimal about dialog with information from the application's bundle.
        ///       The menu bar can be disabled with a compile-time option.
        /// </para>
        /// <para>
        /// OS X: On OS X 10.10 and later the window frame will not be rendered at full resolution on Retina displays
        ///       unless the NSHighResolutionCapable key is enabled in the application bundle's Info.plist.
        ///       For more information, see High Resolution Guidelines for OS X in the Mac Developer Library.
        ///       The GLFW test and example programs use a custom Info.plist template for this, which can be found as
        /// CMake/MacOSXBundleInfo.plist.in in the source tree.
        /// </para>
        /// <para>
        /// X11: Some window managers will not respect the placement of initially hidden windows.
        /// X11: Due to the asynchronous nature of X11, it may take a moment for a window to reach its requested state.
        ///      This means you may not be able to query the final size, position or other attributes directly after window
        /// creation.
        /// </para>
        /// <para>
        /// This function must not be called from a callback.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidEnum"/>,
        /// <see cref = "ErrorCode.InvalidValue"/>, <see cref = "ErrorCode.ApiUnavailable"/>,
        /// <see cref = "ErrorCode.VersionUnavailable"/>, <see cref = "ErrorCode.FormatUnavailable"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.WindowHandle* CreateWindow(int width, int height, string title, global::Silk.NET.GLFW.Monitor* monitor, global::Silk.NET.GLFW.WindowHandle* share)
        {
            void* n10;
            byte* n5;
            Console.WriteLine("Begin CreateWindow");
            Console.WriteLine("PostInit CreateWindow");
            Console.WriteLine("PreLoad CreateWindow");
            n5 = (byte*)Silk.NET.Core.Native.SilkMarshal.StringToPtr((title), (Silk.NET.Core.Native.NativeStringEncoding)48);
            n10 = ((delegate* unmanaged[Cdecl]<int, int, void*, void*, void*, void*> )(CurrentVTable as GeneratedVTable).glfwCreateWindow)((width), (height), ((void*)(n5)), ((void*)(monitor)), ((void*)(share)));
            Console.WriteLine("PostLoad CreateWindow");
            title = Silk.NET.Core.Native.SilkMarshal.PtrToString((global::System.IntPtr)(void*)(n5), (Silk.NET.Core.Native.NativeStringEncoding)48);
            Silk.NET.Core.Native.SilkMarshal.FreeString((global::System.IntPtr)n5, (Silk.NET.Core.Native.NativeStringEncoding)48);
            Console.WriteLine("End CreateWindow");
            return ((Silk.NET.GLFW.WindowHandle*)n10);
        }

        /// <summary>
        /// <para>
        /// This function returns the primary monitor.
        /// </para>
        /// <para>
        /// This is usually the monitor where elements like the task bar or global menu bar are located.
        /// </para>
        /// </summary>
        /// <returns>The primary monitor, or <c>null</c> if no monitors were found or if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// The primary monitor is always first in the array returned by <see cref = "GetMonitors"/>.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.Monitor* GetPrimaryMonitor()
        {
            void* n1;
            Console.WriteLine("Begin GetPrimaryMonitor");
            Console.WriteLine("PostInit GetPrimaryMonitor");
            Console.WriteLine("PreLoad GetPrimaryMonitor");
            n1 = ((delegate* unmanaged[Cdecl]<void*> )(CurrentVTable as GeneratedVTable).glfwGetPrimaryMonitor)();
            Console.WriteLine("PostLoad GetPrimaryMonitor");
            Console.WriteLine("End GetPrimaryMonitor");
            return ((Silk.NET.GLFW.Monitor*)n1);
        }

        /// <summary>
        /// <para>
        /// This function destroys the specified window and its context. On calling this function,
        /// no further callbacks will be called for that window.
        /// </para>
        /// <para>
        /// If the context of the specified window is current on the main thread, it is detached before being destroyed.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to destroy.</param>
        /// <remarks>
        /// <para>
        /// The context of the specified window must not be current on any other thread when this function is called.
        /// </para>
        /// <para>
        /// This function must not be called from a callback.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "CreateWindow"/>
        public unsafe partial void DestroyWindow(global::Silk.NET.GLFW.WindowHandle* window)
        {
            Console.WriteLine("Begin DestroyWindow");
            Console.WriteLine("PostInit DestroyWindow");
            Console.WriteLine("PreLoad DestroyWindow");
            ((delegate* unmanaged[Cdecl]<void*, void> )(CurrentVTable as GeneratedVTable).glfwDestroyWindow)(((void*)(window)));
            Console.WriteLine("PostLoad DestroyWindow");
            Console.WriteLine("End DestroyWindow");
        }

        /// <summary>
        /// <para>
        /// This function brings the specified window to front and sets input focus.
        /// The window should already be visible and not iconified.
        /// </para>
        /// <para>
        /// By default, both windowed and full screen mode windows are focused when initially created.
        /// Set the <see cref = "WindowHintBool.Focused"/> to disable this behavior.
        /// </para>
        /// <para>
        /// Do not use this function to steal focus from other applications unless you are certain
        /// that is what the user wants.
        /// Focus stealing can be extremely disruptive.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to give input focus.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void FocusWindow(global::Silk.NET.GLFW.WindowHandle* window)
        {
            Console.WriteLine("Begin FocusWindow");
            Console.WriteLine("PostInit FocusWindow");
            Console.WriteLine("PreLoad FocusWindow");
            ((delegate* unmanaged[Cdecl]<void*, void> )(CurrentVTable as GeneratedVTable).glfwFocusWindow)(((void*)(window)));
            Console.WriteLine("PostLoad FocusWindow");
            Console.WriteLine("End FocusWindow");
        }

        /// /// <summary>
        /// <para>
        /// This function retrieves the size, in pixels, of the framebuffer of the specified window.
        /// If you wish to retrieve the size of the window in screen coordinates, see <see cref = "GetWindowSize"/>.
        /// </para>
        /// <para>
        /// Any or all of the size arguments may be <c>out _</c>.
        /// If an error occurs, all non-<c>out _</c> size arguments will be set to zero.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose framebuffer to query.</param>
        /// <param name = "width">Where to store the width, in pixels, of the framebuffer.</param>
        /// <param name = "height">Where to store the height, in pixels, of the framebuffer.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void GetFramebufferSize(global::Silk.NET.GLFW.WindowHandle* window, out int width, out int height)
        {
            Console.WriteLine("Begin GetFramebufferSize");
            Console.WriteLine("PostInit GetFramebufferSize");
            fixed (int* SPECIAL_VAR3 = &width)
                fixed (int* SPECIAL_VAR4 = &height)
                {
                    Console.WriteLine("PreLoad GetFramebufferSize");
                    ((delegate* unmanaged[Cdecl]<void*, void*, void*, void> )(CurrentVTable as GeneratedVTable).glfwGetFramebufferSize)(((void*)(window)), ((void*)(SPECIAL_VAR3)), ((void*)(SPECIAL_VAR4)));
                    Console.WriteLine("PostLoad GetFramebufferSize");
                    Console.WriteLine("End GetFramebufferSize");
                }
        }

        /// <summary>
        /// <para>
        /// This function returns the value of an input option for the specified window.
        /// The mode must be <see cref = "CursorStateAttribute.Cursor"/> or <see cref = "CursorStateAttribute.RawMouseMotion"/>.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to query.</param>
        /// <param name = "mode">
        /// <see cref = "CursorStateAttribute.Cursor"/>.
        /// </param>
        /// <returns>Either the CursorModeValue or bool dependant on <paramref name = "mode"/>.</returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidEnum"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "SetInputMode(WindowHandle*, CursorStateAttribute, CursorModeValue)"/>
        /// <seealso cref = "SetInputMode(WindowHandle*, CursorStateAttribute, bool)"/>
        public unsafe partial int GetInputMode(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.CursorStateAttribute mode)
        {
            int n4;
            Console.WriteLine("Begin GetInputMode");
            Console.WriteLine("PostInit GetInputMode");
            Console.WriteLine("PreLoad GetInputMode");
            n4 = ((delegate* unmanaged[Cdecl]<void*, int, int> )(CurrentVTable as GeneratedVTable).glfwGetInputMode)(((void*)(window)), ((int)(mode)));
            Console.WriteLine("PostLoad GetInputMode");
            Console.WriteLine("End GetInputMode");
            return n4;
        }

        /// <summary>
        /// <para>
        /// This function returns the value of an input option for the specified window.
        /// The mode must be <see cref = "StickyAttributes.StickyKeys"/> or <see cref = "StickyAttributes.StickyMouseButtons"/>.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to query.</param>
        /// <param name = "mode">
        /// Either <see cref = "StickyAttributes.StickyKeys"/> or <see cref = "StickyAttributes.StickyMouseButtons"/>.
        /// </param>
        /// <returns>TODO: return value is either InputModeValue or bool dependant on <paramref name = "mode"/>.</returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidEnum"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "SetInputMode(WindowHandle*, StickyAttributes, bool)"/>
        public unsafe partial bool GetInputMode(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.StickyAttributes mode)
        {
            byte n5;
            Console.WriteLine("Begin GetInputMode");
            Console.WriteLine("PostInit GetInputMode");
            Console.WriteLine("PreLoad GetInputMode");
            n5 = ((delegate* unmanaged[Cdecl]<void*, int, byte> )(CurrentVTable as GeneratedVTable).glfwGetInputMode)(((void*)(window)), ((int)(mode)));
            Console.WriteLine("PostLoad GetInputMode");
            Console.WriteLine("End GetInputMode");
            return (n5 >= 1);
        }

        /// <summary>
        /// <para>
        /// This function restores the specified window if it was previously iconified (minimized) or maximized.
        /// If the window is already restored, this function does nothing.
        /// </para>
        /// <para>
        /// If the specified window is a full screen window, the resolution chosen for the window is restored on the selected
        /// monitor.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to restore.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void RestoreWindow(global::Silk.NET.GLFW.WindowHandle* window)
        {
            Console.WriteLine("Begin RestoreWindow");
            Console.WriteLine("PostInit RestoreWindow");
            Console.WriteLine("PreLoad RestoreWindow");
            ((delegate* unmanaged[Cdecl]<void*, void> )(CurrentVTable as GeneratedVTable).glfwRestoreWindow)(((void*)(window)));
            Console.WriteLine("PostLoad RestoreWindow");
            Console.WriteLine("End RestoreWindow");
        }

        /// <summary>
        /// <para>
        /// This function returns the current video mode of the specified monitor.
        /// </para>
        /// <para>
        /// If you have created a full screen window for that monitor,
        /// the return value will depend on whether that window is iconified.
        /// </para>
        /// </summary>
        /// <param name = "monitor">The monitor to query. </param>
        /// <returns>The current mode of the monitor, or <c>null</c> if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// The returned array is allocated and freed by GLFW
        /// You should not free it yourself.
        /// It is valid until the specified monitor is disconnected or the library is terminated.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "GetVideoModes"/>
        public unsafe partial global::Silk.NET.GLFW.VideoMode* GetVideoMode(global::Silk.NET.GLFW.Monitor* monitor)
        {
            void* n3;
            Console.WriteLine("Begin GetVideoMode");
            Console.WriteLine("PostInit GetVideoMode");
            Console.WriteLine("PreLoad GetVideoMode");
            n3 = ((delegate* unmanaged[Cdecl]<void*, void*> )(CurrentVTable as GeneratedVTable).glfwGetVideoMode)(((void*)(monitor)));
            Console.WriteLine("PostLoad GetVideoMode");
            Console.WriteLine("End GetVideoMode");
            return ((Silk.NET.GLFW.VideoMode*)n3);
        }

        /// <summary>
        /// <para>
        /// This function returns the value of an attribute of the specified window or its OpenGL or OpenGL ES context.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to query.</param>
        /// <param name = "attribute">The window attribute whose value to return.</param>
        /// <returns>The value of the attribute, or zero if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// Framebuffer-related hints are not window attributes. See
        /// <a href="https://www.glfw.org/docs/3.3/window_guide.html#window_hints_fb">
        /// Framebuffer related attributes
        /// </a>
        /// for more information.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidEnum"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial bool GetWindowAttrib(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.WindowAttributeGetter attribute)
        {
            byte n5;
            Console.WriteLine("Begin GetWindowAttrib");
            Console.WriteLine("PostInit GetWindowAttrib");
            Console.WriteLine("PreLoad GetWindowAttrib");
            n5 = ((delegate* unmanaged[Cdecl]<void*, int, byte> )(CurrentVTable as GeneratedVTable).glfwGetWindowAttrib)(((void*)(window)), ((int)(attribute)));
            Console.WriteLine("PostLoad GetWindowAttrib");
            Console.WriteLine("End GetWindowAttrib");
            return (n5 >= 1);
        }

        /// <summary>
        /// <para>
        /// This function retrieves the size, in screen coordinates, of the client area of the specified window.
        /// If you wish to retrieve the size of the framebuffer of the window in pixels, see <see cref = "GetFramebufferSize"/>.
        /// </para>
        /// <para>
        /// Any or all of the size arguments may be <c>out _</c>.
        /// If an error occurs, all non-<c>out _</c> size arguments will be set to zero.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose size to retrieve.</param>
        /// <param name = "width">Where to store the width, in screen coordinates, of the client area.</param>
        /// <param name = "height">Where to store the height, in screen coordinates, of the client area.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "SetWindowSize"/>
        public unsafe partial void GetWindowSize(global::Silk.NET.GLFW.WindowHandle* window, out int width, out int height)
        {
            Console.WriteLine("Begin GetWindowSize");
            Console.WriteLine("PostInit GetWindowSize");
            fixed (int* SPECIAL_VAR3 = &width)
                fixed (int* SPECIAL_VAR4 = &height)
                {
                    Console.WriteLine("PreLoad GetWindowSize");
                    ((delegate* unmanaged[Cdecl]<void*, void*, void*, void> )(CurrentVTable as GeneratedVTable).glfwGetWindowSize)(((void*)(window)), ((void*)(SPECIAL_VAR3)), ((void*)(SPECIAL_VAR4)));
                    Console.WriteLine("PostLoad GetWindowSize");
                    Console.WriteLine("End GetWindowSize");
                }
        }

        /// <summary>
        /// <para>
        /// This function retrieves the position, in screen coordinates,
        /// of the upper-left corner of the client area of the specified window.
        /// </para>
        /// <para>
        /// Any or all of the position arguments may be <c>out _</c>.
        /// If an error occurs, all non-<c>out _</c> position arguments will be set to zero.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to query.</param>
        /// <param name = "x">Where to store the x-coordinate of the upper-left corner of the client area.</param>
        /// <param name = "y">Where to store the y-coordinate of the upper-left corner of the client area.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "SetWindowPos"/>
        public unsafe partial void GetWindowPos(global::Silk.NET.GLFW.WindowHandle* window, out int x, out int y)
        {
            Console.WriteLine("Begin GetWindowPos");
            Console.WriteLine("PostInit GetWindowPos");
            fixed (int* SPECIAL_VAR3 = &x)
                fixed (int* SPECIAL_VAR4 = &y)
                {
                    Console.WriteLine("PreLoad GetWindowPos");
                    ((delegate* unmanaged[Cdecl]<void*, void*, void*, void> )(CurrentVTable as GeneratedVTable).glfwGetWindowPos)(((void*)(window)), ((void*)(SPECIAL_VAR3)), ((void*)(SPECIAL_VAR4)));
                    Console.WriteLine("PostLoad GetWindowPos");
                    Console.WriteLine("End GetWindowPos");
                }
        }

        /// <summary>
        /// <para>
        /// This function returns the handle of the monitor that the specified window is in full screen on.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to query.</param>
        /// <returns>The monitor, or <c>null</c> if the window is in windowed mode or an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "SetWindowMonitor"/>
        public unsafe partial global::Silk.NET.GLFW.Monitor* GetWindowMonitor(global::Silk.NET.GLFW.WindowHandle* window)
        {
            void* n3;
            Console.WriteLine("Begin GetWindowMonitor");
            Console.WriteLine("PostInit GetWindowMonitor");
            Console.WriteLine("PreLoad GetWindowMonitor");
            n3 = ((delegate* unmanaged[Cdecl]<void*, void*> )(CurrentVTable as GeneratedVTable).glfwGetWindowMonitor)(((void*)(window)));
            Console.WriteLine("PostLoad GetWindowMonitor");
            Console.WriteLine("End GetWindowMonitor");
            return ((Silk.NET.GLFW.Monitor*)n3);
        }

        /// <summary>
        /// <para>
        /// This function hides the specified window if it was previously visible.
        /// If the window is already hidden or is in full screen mode, this function does nothing.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to hide.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void HideWindow(global::Silk.NET.GLFW.WindowHandle* window)
        {
            Console.WriteLine("Begin HideWindow");
            Console.WriteLine("PostInit HideWindow");
            Console.WriteLine("PreLoad HideWindow");
            ((delegate* unmanaged[Cdecl]<void*, void> )(CurrentVTable as GeneratedVTable).glfwHideWindow)(((void*)(window)));
            Console.WriteLine("PostLoad HideWindow");
            Console.WriteLine("End HideWindow");
        }

        /// <summary>
        /// <para>
        /// This function iconifies (minimizes) the specified window if it was previously restored.
        /// If the window is already iconified, this function does nothing.
        /// </para>
        /// <para>
        /// If the specified window is a full screen window,
        /// the original monitor resolution is restored until the window is restored.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to iconify.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void IconifyWindow(global::Silk.NET.GLFW.WindowHandle* window)
        {
            Console.WriteLine("Begin IconifyWindow");
            Console.WriteLine("PostInit IconifyWindow");
            Console.WriteLine("PreLoad IconifyWindow");
            ((delegate* unmanaged[Cdecl]<void*, void> )(CurrentVTable as GeneratedVTable).glfwIconifyWindow)(((void*)(window)));
            Console.WriteLine("PostLoad IconifyWindow");
            Console.WriteLine("End IconifyWindow");
        }

        /// <summary>
        /// <para>
        /// This function makes the OpenGL or OpenGL ES context of the specified window current on the calling thread.
        /// </para>
        /// <para>
        /// A context can only be made current on a single thread at a time
        /// and each thread can have only a single current context at a time.
        /// </para>
        /// <para>
        /// By default, making a context non-current implicitly forces a pipeline flush.
        /// </para>
        /// <para>
        /// On machines that support <c>GL_KHR_context_flush_control</c>,
        /// you can control whether a context performs this flush
        /// by setting the <see cref = "WindowHintReleaseBehavior.ContextReleaseBehavior"/> window hint.
        /// </para>
        /// <para>
        /// The specified window must have an OpenGL or OpenGL ES context.
        /// Specifying a window without a context will generate a <see cref = "ErrorCode.NoWindowContext"/> error.
        /// </para>
        /// </summary>
        /// <param name = "window">
        /// The window whose context to make current, or <c>null</c> to detach the current context.
        /// </param>
        /// <remarks>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.NoWindowContext"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "GetCurrentContext"/>
        public unsafe partial void MakeContextCurrent(global::Silk.NET.GLFW.WindowHandle* window)
        {
            Console.WriteLine("Begin MakeContextCurrent");
            Console.WriteLine("PostInit MakeContextCurrent");
            Console.WriteLine("PreLoad MakeContextCurrent");
            ((delegate* unmanaged[Cdecl]<void*, void> )(CurrentVTable as GeneratedVTable).glfwMakeContextCurrent)(((void*)(window)));
            Console.WriteLine("PostLoad MakeContextCurrent");
            Console.WriteLine("End MakeContextCurrent");
        }

        /// <summary>
        /// <para>
        /// This function maximizes the specified window if it was previously not maximized.
        /// If the window is already maximized, this function does nothing.
        /// </para>
        /// <para>
        /// If the specified window is a full screen window, this function does nothing.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to maximize.</param>
        /// <remarks>
        /// <para>
        /// This function may only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void MaximizeWindow(global::Silk.NET.GLFW.WindowHandle* window)
        {
            Console.WriteLine("Begin MaximizeWindow");
            Console.WriteLine("PostInit MaximizeWindow");
            Console.WriteLine("PreLoad MaximizeWindow");
            ((delegate* unmanaged[Cdecl]<void*, void> )(CurrentVTable as GeneratedVTable).glfwMaximizeWindow)(((void*)(window)));
            Console.WriteLine("PostLoad MaximizeWindow");
            Console.WriteLine("End MaximizeWindow");
        }

        /// <summary>
        /// <para>
        /// This function processes only those events that are already in the event queue and then returns immediately.
        /// Processing events will cause the window and input callbacks associated with those events to be called.
        /// </para>
        /// <para>
        /// On some platforms, a window move, resize or menu operation will cause event processing to block.
        /// This is due to how event processing is designed on those platforms.
        /// You can use the
        /// <a href="https://www.glfw.org/docs/latest/window_guide.html#window_refresh">window refresh callback</a>
        /// to redraw the contents of your window when necessary during such operations.
        /// </para>
        /// <para>
        /// On some platforms, certain events are sent directly to the application without going through the event queue,
        /// causing callbacks to be called outside of a call to one of the event processing functions.
        /// </para>
        /// <para>
        /// Event processing is not required for joystick input to work.
        /// </para>
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function must not be called from a callback.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public partial void PollEvents()
        {
            unsafe
            {
                Console.WriteLine("Begin PollEvents");
                Console.WriteLine("PostInit PollEvents");
                Console.WriteLine("PreLoad PollEvents");
                ((delegate* unmanaged[Cdecl]<void> )(CurrentVTable as GeneratedVTable).glfwPollEvents)();
                Console.WriteLine("PostLoad PollEvents");
                Console.WriteLine("End PollEvents");
            }
        }

        /// <summary>
        /// <para>
        /// This function posts an empty event from the current thread to the event queue,
        /// causing <see cref = "WaitEvents"/> or <see cref = "WaitEventsTimeout"/> to return.
        /// </para>
        /// <para>
        /// If no windows exist, this function returns immediately.
        /// For synchronization of threads in applications that do not create windows, use your threading library of choice.
        /// </para>
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public partial void PostEmptyEvent()
        {
            unsafe
            {
                Console.WriteLine("Begin PostEmptyEvent");
                Console.WriteLine("PostInit PostEmptyEvent");
                Console.WriteLine("PreLoad PostEmptyEvent");
                ((delegate* unmanaged[Cdecl]<void> )(CurrentVTable as GeneratedVTable).glfwPostEmptyEvent)();
                Console.WriteLine("PostLoad PostEmptyEvent");
                Console.WriteLine("End PostEmptyEvent");
            }
        }

        /// <summary>
        /// <para>
        /// This function sets hints for the next call to <see cref = "CreateWindow"/>.
        /// The hints, once set, retain their values
        /// until changed by a call to <see cref = "WindowHint(WindowHintInt, int)"/>
        /// or <see cref = "DefaultWindowHints"/>, or until the library is terminated.
        /// </para>
        /// <para>
        /// This function does not check whether the specified hint values are valid.
        /// If you set hints to invalid values this will instead be reported
        /// by the next call to <see cref = "CreateWindow"/>.
        /// </para>
        /// </summary>
        /// <param name = "hint">The <see cref = "WindowHintInt"/> to set.</param>
        /// <param name = "value">The new value of the framebuffer attribute hint.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidEnum"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "DefaultWindowHints"/>
        public partial void WindowHint(global::Silk.NET.GLFW.WindowHintInt hint, int value)
        {
            unsafe
            {
                Console.WriteLine("Begin WindowHint");
                Console.WriteLine("PostInit WindowHint");
                Console.WriteLine("PreLoad WindowHint");
                ((delegate* unmanaged[Cdecl]<int, int, void> )(CurrentVTable as GeneratedVTable).glfwWindowHint)(((int)(hint)), (value));
                Console.WriteLine("PostLoad WindowHint");
                Console.WriteLine("End WindowHint");
            }
        }

        /// <summary>
        /// <para>
        /// This function sets hints for the next call to <see cref = "CreateWindow"/>.
        /// The hints, once set, retain their values
        /// until changed by a call to <see cref = "WindowHint(WindowHintBool, bool)"/>
        /// or <see cref = "DefaultWindowHints"/>, or until the library is terminated.
        /// </para>
        /// <para>
        /// This function does not check whether the specified hint values are valid.
        /// If you set hints to invalid values this will instead be reported
        /// by the next call to <see cref = "CreateWindow"/>.
        /// </para>
        /// </summary>
        /// <param name = "hint">The <see cref = "WindowHintInt"/> to set.</param>
        /// <param name = "value">The new value of the framebuffer attribute hint.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidEnum"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "DefaultWindowHints"/>
        public partial void WindowHint(global::Silk.NET.GLFW.WindowHintBool hint, bool value)
        {
            unsafe
            {
                Console.WriteLine("Begin WindowHint");
                Console.WriteLine("PostInit WindowHint");
                Console.WriteLine("PreLoad WindowHint");
                ((delegate* unmanaged[Cdecl]<int, byte, void> )(CurrentVTable as GeneratedVTable).glfwWindowHint)(((int)(hint)), ((value) ? (byte)1 : (byte)0));
                Console.WriteLine("PostLoad WindowHint");
                Console.WriteLine("End WindowHint");
            }
        }

        /// <summary>
        /// <para>
        /// This function sets hints for the next call to <see cref = "CreateWindow"/>.
        /// The hints, once set, retain their values
        /// until changed by a call to <see cref = "WindowHint(WindowHintClientApi, ClientApi)"/>
        /// or <see cref = "DefaultWindowHints"/>, or until the library is terminated.
        /// </para>
        /// <para>
        /// This function does not check whether the specified hint values are valid.
        /// If you set hints to invalid values this will instead be reported
        /// by the next call to <see cref = "CreateWindow"/>.
        /// </para>
        /// </summary>
        /// <param name = "hint"><see cref = "WindowHintClientApi.ClientApi"/>.</param>
        /// <param name = "value">The new value of the window hint.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidEnum"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "DefaultWindowHints"/>
        public partial void WindowHint(global::Silk.NET.GLFW.WindowHintClientApi hint, global::Silk.NET.GLFW.ClientApi value)
        {
            unsafe
            {
                Console.WriteLine("Begin WindowHint");
                Console.WriteLine("PostInit WindowHint");
                Console.WriteLine("PreLoad WindowHint");
                ((delegate* unmanaged[Cdecl]<int, int, void> )(CurrentVTable as GeneratedVTable).glfwWindowHint)(((int)(hint)), ((int)(value)));
                Console.WriteLine("PostLoad WindowHint");
                Console.WriteLine("End WindowHint");
            }
        }

        /// <summary>
        /// <para>
        /// This function sets hints for the next call to <see cref = "CreateWindow"/>.
        /// The hints, once set, retain their values
        /// until changed by a call to <see cref = "WindowHint(WindowHintReleaseBehavior, ReleaseBehavior)"/>
        /// or <see cref = "DefaultWindowHints"/>, or until the library is terminated.
        /// </para>
        /// <para>
        /// This function does not check whether the specified hint values are valid.
        /// If you set hints to invalid values this will instead be reported
        /// by the next call to <see cref = "CreateWindow"/>.
        /// </para>
        /// </summary>
        /// <param name = "hint"><see cref = "WindowHintReleaseBehavior.ContextReleaseBehavior"/>.</param>
        /// <param name = "value">The new value of the window hint.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidEnum"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "DefaultWindowHints"/>
        public partial void WindowHint(global::Silk.NET.GLFW.WindowHintReleaseBehavior hint, global::Silk.NET.GLFW.ReleaseBehavior value)
        {
            unsafe
            {
                Console.WriteLine("Begin WindowHint");
                Console.WriteLine("PostInit WindowHint");
                Console.WriteLine("PreLoad WindowHint");
                ((delegate* unmanaged[Cdecl]<int, int, void> )(CurrentVTable as GeneratedVTable).glfwWindowHint)(((int)(hint)), ((int)(value)));
                Console.WriteLine("PostLoad WindowHint");
                Console.WriteLine("End WindowHint");
            }
        }

        /// <summary>
        /// <para>
        /// This function sets hints for the next call to <see cref = "CreateWindow"/>.
        /// The hints, once set, retain their values
        /// until changed by a call to <see cref = "WindowHint(WindowHintContextApi, ContextApi)"/>
        /// or <see cref = "DefaultWindowHints"/>, or until the library is terminated.
        /// </para>
        /// <para>
        /// This function does not check whether the specified hint values are valid.
        /// If you set hints to invalid values this will instead be reported
        /// by the next call to <see cref = "CreateWindow"/>.
        /// </para>
        /// </summary>
        /// <param name = "hint"><see cref = "WindowHintContextApi.ContextCreationApi"/>.</param>
        /// <param name = "value">The new value of the window hint.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidEnum"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "DefaultWindowHints"/>
        public partial void WindowHint(global::Silk.NET.GLFW.WindowHintContextApi hint, global::Silk.NET.GLFW.ContextApi value)
        {
            unsafe
            {
                Console.WriteLine("Begin WindowHint");
                Console.WriteLine("PostInit WindowHint");
                Console.WriteLine("PreLoad WindowHint");
                ((delegate* unmanaged[Cdecl]<int, int, void> )(CurrentVTable as GeneratedVTable).glfwWindowHint)(((int)(hint)), ((int)(value)));
                Console.WriteLine("PostLoad WindowHint");
                Console.WriteLine("End WindowHint");
            }
        }

        /// <summary>
        /// <para>
        /// This function sets hints for the next call to <see cref = "CreateWindow"/>.
        /// The hints, once set, retain their values
        /// until changed by a call to <see cref = "WindowHint(WindowHintRobustness, Robustness)"/>
        /// or <see cref = "DefaultWindowHints"/>, or until the library is terminated.
        /// </para>
        /// <para>
        /// This function does not check whether the specified hint values are valid.
        /// If you set hints to invalid values this will instead be reported
        /// by the next call to <see cref = "CreateWindow"/>.
        /// </para>
        /// </summary>
        /// <param name = "hint"><see cref = "WindowHintRobustness.ContextRobustness"/>.</param>
        /// <param name = "value">The new value of the window hint.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidEnum"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "DefaultWindowHints"/>
        public partial void WindowHint(global::Silk.NET.GLFW.WindowHintRobustness hint, global::Silk.NET.GLFW.Robustness value)
        {
            unsafe
            {
                Console.WriteLine("Begin WindowHint");
                Console.WriteLine("PostInit WindowHint");
                Console.WriteLine("PreLoad WindowHint");
                ((delegate* unmanaged[Cdecl]<int, int, void> )(CurrentVTable as GeneratedVTable).glfwWindowHint)(((int)(hint)), ((int)(value)));
                Console.WriteLine("PostLoad WindowHint");
                Console.WriteLine("End WindowHint");
            }
        }

        /// <summary>
        /// <para>
        /// This function sets hints for the next call to <see cref = "CreateWindow"/>.
        /// The hints, once set, retain their values
        /// until changed by a call to <see cref = "WindowHint(WindowHintOpenGlProfile, OpenGlProfile)"/>
        /// or <see cref = "DefaultWindowHints"/>, or until the library is terminated.
        /// </para>
        /// <para>
        /// This function does not check whether the specified hint values are valid.
        /// If you set hints to invalid values this will instead be reported
        /// by the next call to <see cref = "CreateWindow"/>.
        /// </para>
        /// </summary>
        /// <param name = "hint"><see cref = "WindowHintOpenGlProfile.OpenGlProfile"/>.</param>
        /// <param name = "value">The new value of the window hint.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.InvalidEnum"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "DefaultWindowHints"/>
        public partial void WindowHint(global::Silk.NET.GLFW.WindowHintOpenGlProfile hint, global::Silk.NET.GLFW.OpenGlProfile value)
        {
            unsafe
            {
                Console.WriteLine("Begin WindowHint");
                Console.WriteLine("PostInit WindowHint");
                Console.WriteLine("PreLoad WindowHint");
                ((delegate* unmanaged[Cdecl]<int, int, void> )(CurrentVTable as GeneratedVTable).glfwWindowHint)(((int)(hint)), ((int)(value)));
                Console.WriteLine("PostLoad WindowHint");
                Console.WriteLine("End WindowHint");
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the value of the close flag of the specified window.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to query.</param>
        /// <returns>The value of the close flag.</returns>
        /// <remarks>
        /// <para>
        /// This function may be called from any thread. Access is not synchronized.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial bool WindowShouldClose(global::Silk.NET.GLFW.WindowHandle* window)
        {
            byte n3;
            Console.WriteLine("Begin WindowShouldClose");
            Console.WriteLine("PostInit WindowShouldClose");
            Console.WriteLine("PreLoad WindowShouldClose");
            n3 = ((delegate* unmanaged[Cdecl]<void*, byte> )(CurrentVTable as GeneratedVTable).glfwWindowShouldClose)(((void*)(window)));
            Console.WriteLine("PostLoad WindowShouldClose");
            Console.WriteLine("End WindowShouldClose");
            return (n3 >= 1);
        }

        /// <summary>
        /// <para>
        /// This function sets the character callback of the specified window, which is called when a Unicode character is input.
        /// </para>
        /// <para>
        /// The character callback is intended for Unicode text input. As it deals with characters,
        /// it is keyboard layout dependent, whereas the key callback is not. Characters do not map 1:1 to physical keys
        /// as a key may produce zero, one, or more characters.
        /// </para>
        /// <para>
        /// If you want to know whether a specific physical key was pressed or released, see the key callback instead.
        /// </para>
        /// <para>
        /// The character callback behaves as system text input normally does
        /// and will not be called if modifier keys are held down that would prevent normal text input on that platform,
        /// for example a Super (Command) key on OS X or Alt key on Windows.
        /// </para>
        /// <para>
        /// There is a character with modifiers callback(<see cref = "SetCharModsCallback"/>) that receives these events.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.CharCallback SetCharCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.CharCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetCharCallback");
            Console.WriteLine("PostInit SetCharCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetCharCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetCharCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetCharCallback");
            Console.WriteLine("End SetCharCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.CharCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the character with modifiers callback of the specified window,
        /// which is called when a Unicode character is input regardless of what modifier keys are used.
        /// </para>
        /// <para>
        /// The character with modifiers callback is intended for implementing custom Unicode character input.
        /// For regular Unicode text input, see the character callback.
        /// </para>
        /// <para>
        /// Like the character callback(<see cref = "SetCharCallback"/>),
        /// the character with modifiers callback deals with characters and is keyboard layout dependent.
        /// Characters do not map 1:1 to physical keys, as a key may produce zero, one, or more characters.
        /// </para>
        /// <para>
        /// If you want to know whether a specific physical key was pressed or released,
        /// see the key callback(<see cref = "SetKeyCallback"/>) instead.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>The previously set callback, or <c>null</c> if no callback was set or an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.CharModsCallback SetCharModsCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.CharModsCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetCharModsCallback");
            Console.WriteLine("PostInit SetCharModsCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetCharModsCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetCharModsCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetCharModsCallback");
            Console.WriteLine("End SetCharModsCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.CharModsCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the cursor boundary crossing callback of the specified window
        /// which is called when the cursor enters or leaves the client area of the window.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.CursorEnterCallback SetCursorEnterCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.CursorEnterCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetCursorEnterCallback");
            Console.WriteLine("PostInit SetCursorEnterCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetCursorEnterCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetCursorEnterCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetCursorEnterCallback");
            Console.WriteLine("End SetCursorEnterCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.CursorEnterCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the cursor position callback of the specified window,
        /// which is called when the cursor is moved.
        /// </para>
        /// <para>
        /// The callback is provided with the position, in screen coordinates,
        /// relative to the upper-left corner of the client area of the window.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.CursorPosCallback SetCursorPosCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.CursorPosCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetCursorPosCallback");
            Console.WriteLine("PostInit SetCursorPosCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetCursorPosCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetCursorPosCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetCursorPosCallback");
            Console.WriteLine("End SetCursorPosCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.CursorPosCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the file drop callback of the specified window,
        /// which is called when one or more dragged files are dropped on the window.
        /// </para>
        /// <para>
        /// Because the path array and its strings may have been generated specifically for that event,
        /// they are not guaranteed to be valid after the callback has returned.
        /// If you wish to use them after the callback returns, you need to make a deep copy.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new file drop callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.DropCallback SetDropCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.DropCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetDropCallback");
            Console.WriteLine("PostInit SetDropCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetDropCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetDropCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetDropCallback");
            Console.WriteLine("End SetDropCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.DropCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the error callback, which is called with an error code
        /// and a human-readable description each time a GLFW error occurs.
        /// </para>
        /// <para>
        /// The error callback is called on the thread where the error occurred.
        /// If you are using GLFW from multiple threads, your error callback needs to be written accordingly.
        /// </para>
        /// <para>
        /// Because the description string may have been generated specifically for that error,
        /// it is not guaranteed to be valid after the callback has returned.
        /// If you wish to use it after the callback returns, you need to make a deep copy.
        /// </para>
        /// <para>
        /// Once set, the error callback remains set even after the library has been terminated.
        /// </para>
        /// </summary>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>The previously set callback, or <c>null</c> if no callback was set.</returns>
        /// <remarks>
        /// <para>
        /// This function may be called before <see cref = "Init"/>.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// </remarks>
        public partial global::Silk.NET.GLFW.GlfwCallbacks.ErrorCallback SetErrorCallback(global::Silk.NET.GLFW.GlfwCallbacks.ErrorCallback callback)
        {
            unsafe
            {
                global::System.IntPtr n3;
                Console.WriteLine("Begin SetErrorCallback");
                Console.WriteLine("PostInit SetErrorCallback");
                this.PinUntilNextCall((callback), 0);
                Console.WriteLine("PreLoad SetErrorCallback");
                n3 = ((delegate* unmanaged[Cdecl]<global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetErrorCallback)((callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
                Console.WriteLine("PostLoad SetErrorCallback");
                Console.WriteLine("End SetErrorCallback");
                return (n3 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.ErrorCallback>(n3));
            }
        }

        /// <summary>
        /// <para>
        /// This function sets the error callback, which is called with an error code
        /// and a human-readable description each time a GLFW error occurs.
        /// </para>
        /// <para>
        /// The error callback is called on the thread where the error occurred.
        /// If you are using GLFW from multiple threads, your error callback needs to be written accordingly.
        /// </para>
        /// <para>
        /// Because the description string may have been generated specifically for that error,
        /// it is not guaranteed to be valid after the callback has returned.
        /// If you wish to use it after the callback returns, you need to make a deep copy.
        /// </para>
        /// <para>
        /// Once set, the error callback remains set even after the library has been terminated.
        /// </para>
        /// </summary>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>The previously set callback, or <c>null</c> if no callback was set.</returns>
        /// <remarks>
        /// <para>
        /// This function may be called before <see cref = "Init"/>.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// </remarks>
        public unsafe partial delegate* unmanaged<int, void*, void> SetErrorCallback(delegate* unmanaged<int, void*, void> errorCallback)
        {
            void* n3;
            Console.WriteLine("Begin SetErrorCallback");
            Console.WriteLine("PostInit SetErrorCallback");
            Console.WriteLine("PreLoad SetErrorCallback");
            n3 = ((delegate* unmanaged[Cdecl]<void*, void*> )(CurrentVTable as GeneratedVTable).glfwSetErrorCallback)(((void*)(errorCallback)));
            Console.WriteLine("PostLoad SetErrorCallback");
            Console.WriteLine("End SetErrorCallback");
            return ((delegate* unmanaged<int, void*, void>)n3);
        }

        /// <summary>
        /// <para>
        /// This function sets an input mode option for the specified window.
        /// The mode must be <see cref = "CursorStateAttribute.Cursor"/>.
        /// </para>
        /// <para>
        /// If the mode is <see cref = "CursorStateAttribute.Cursor"/>, the value must be one of the following cursor modes:
        /// - <see cref = "CursorModeValue.CursorNormal"/> makes the cursor visible and behaving normally.
        /// - <see cref = "CursorModeValue.CursorHidden"/> makes the cursor invisible when it is over the client area of
        ///   the window but does not restrict the cursor from leaving.
        /// - <see cref = "CursorModeValue.CursorDisabled"/> hides and grabs the cursor, providing virtual
        ///   and unlimited cursor movement. This is useful for implementing for example 3D camera controls.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose input mode to set.</param>
        /// <param name = "mode"><see cref = "CursorStateAttribute.Cursor"/>.</param>
        /// <param name = "value">The new value of the specified input mode.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidEnum"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void SetInputMode(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.CursorStateAttribute mode, global::Silk.NET.GLFW.CursorModeValue value)
        {
            Console.WriteLine("Begin SetInputMode");
            Console.WriteLine("PostInit SetInputMode");
            Console.WriteLine("PreLoad SetInputMode");
            ((delegate* unmanaged[Cdecl]<void*, int, int, void> )(CurrentVTable as GeneratedVTable).glfwSetInputMode)(((void*)(window)), ((int)(mode)), ((int)(value)));
            Console.WriteLine("PostLoad SetInputMode");
            Console.WriteLine("End SetInputMode");
        }

        /// <summary>
        /// <para>
        /// This function sets an input mode option for the specified window.
        /// The mode must be <see cref = "CursorStateAttribute.RawMouseMotion"/>.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose input mode to set.</param>
        /// <param name = "mode"><see cref = "CursorStateAttribute.RawMouseMotion"/>.</param>
        /// <param name = "value">The new value of the specified input mode.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void SetInputMode(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.CursorStateAttribute mode, bool value)
        {
            Console.WriteLine("Begin SetInputMode");
            Console.WriteLine("PostInit SetInputMode");
            Console.WriteLine("PreLoad SetInputMode");
            ((delegate* unmanaged[Cdecl]<void*, int, byte, void> )(CurrentVTable as GeneratedVTable).glfwSetInputMode)(((void*)(window)), ((int)(mode)), ((value) ? (byte)1 : (byte)0));
            Console.WriteLine("PostLoad SetInputMode");
            Console.WriteLine("End SetInputMode");
        }

        /// <summary>
        /// <para>
        /// This function sets an input mode option for the specified window.
        /// The mode must be <see cref = "StickyAttributes.StickyKeys"/>
        /// or <see cref = "StickyAttributes.StickyMouseButtons"/>.
        /// </para>
        /// <para>
        /// If the mode is <see cref = "StickyAttributes.StickyKeys"/>, the value must be either <c>true</c>
        /// to enable sticky keys, or <c>false</c> to disable it.
        /// </para>
        /// <para>
        /// If sticky keys are enabled, a key press will ensure that
        /// <see cref = "GetKey"/> returns <see cref = "InputAction.Press"/> the next time it is called even if the key had been
        /// released before the call.
        /// This is useful when you are only interested in whether keys have been pressed but not when or in which order.
        /// </para>
        /// <para>
        /// If the mode is <see cref = "StickyAttributes.StickyMouseButtons"/>, the value must be either <c>true</c>
        /// to enable sticky mouse buttons, or <c>false</c> to disable it.
        /// If sticky mouse buttons are enabled, a mouse button press will ensure that
        /// <see cref = "GetMouseButton"/> returns <see cref = "InputAction.Press"/> the next time it is called even if the mouse
        /// button had been released before the call.
        /// This is useful when you are only interested in whether mouse buttons have been pressed but not when or in which order.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose input mode to set.</param>
        /// <param name = "mode">
        /// Either <see cref = "StickyAttributes.StickyKeys"/> or <see cref = "StickyAttributes.StickyMouseButtons"/>.
        /// </param>
        /// <param name = "value">The new value of the specified input mode.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.InvalidEnum"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void SetInputMode(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.StickyAttributes mode, bool value)
        {
            Console.WriteLine("Begin SetInputMode");
            Console.WriteLine("PostInit SetInputMode");
            Console.WriteLine("PreLoad SetInputMode");
            ((delegate* unmanaged[Cdecl]<void*, int, byte, void> )(CurrentVTable as GeneratedVTable).glfwSetInputMode)(((void*)(window)), ((int)(mode)), ((value) ? (byte)1 : (byte)0));
            Console.WriteLine("PostLoad SetInputMode");
            Console.WriteLine("End SetInputMode");
        }

        /// <summary>
        /// <para>
        /// This function sets the joystick configuration callback, or removes the currently set callback.
        /// This is called when a joystick is connected to or disconnected from the system.
        /// </para>
        /// </summary>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public partial global::Silk.NET.GLFW.GlfwCallbacks.JoystickCallback SetJoystickCallback(global::Silk.NET.GLFW.GlfwCallbacks.JoystickCallback callback)
        {
            unsafe
            {
                global::System.IntPtr n3;
                Console.WriteLine("Begin SetJoystickCallback");
                Console.WriteLine("PostInit SetJoystickCallback");
                this.PinUntilNextCall((callback), 0);
                Console.WriteLine("PreLoad SetJoystickCallback");
                n3 = ((delegate* unmanaged[Cdecl]<global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetJoystickCallback)((callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
                Console.WriteLine("PostLoad SetJoystickCallback");
                Console.WriteLine("End SetJoystickCallback");
                return (n3 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.JoystickCallback>(n3));
            }
        }

        /// <summary>
        /// <para>
        /// This function sets the key callback of the specified window, which is called when a key is pressed, repeated or
        /// released.
        /// </para>
        /// <para>
        /// The key functions deal with physical keys, with layout independent
        /// key tokens(<see cref = "Keys"/>) named after their values in the standard US keyboard layout.
        /// If you want to input text, use the character callback(<see cref = "SetCharCallback"/>) instead.
        /// </para>
        /// <para>
        /// When a window loses input focus, it will generate synthetic key release events for all pressed keys.
        /// You can tell these events from user-generated events by the fact that the synthetic ones are generated
        /// after the focus loss event has been processed,
        /// i.e. after the window focus callback(<see cref = "SetWindowFocusCallback"/>) has been called.
        /// </para>
        /// <para>
        /// The scancode of a key is specific to that platform or sometimes even to that machine.
        /// Scancodes are intended to allow users to bind keys that don't have a GLFW key token.
        /// Such keys have key set to <see cref = "Keys.Unknown"/>, their state is not saved
        /// and so it cannot be queried with <see cref = "GetKey"/>.
        /// </para>
        /// <para>
        /// Sometimes GLFW needs to generate synthetic key events, in which case the scancode may be zero.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new key callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.KeyCallback SetKeyCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.KeyCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetKeyCallback");
            Console.WriteLine("PostInit SetKeyCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetKeyCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetKeyCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetKeyCallback");
            Console.WriteLine("End SetKeyCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.KeyCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the scroll callback of the specified window,
        /// which is called when a scrolling device is used, such as a mouse wheel or scrolling area of a touchpad.
        /// </para>
        /// <para>
        /// The scroll callback receives all scrolling input, like that from a mouse wheel or a touchpad scrolling area.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new scroll callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.ScrollCallback SetScrollCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.ScrollCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetScrollCallback");
            Console.WriteLine("PostInit SetScrollCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetScrollCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetScrollCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetScrollCallback");
            Console.WriteLine("End SetScrollCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.ScrollCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the monitor configuration callback, or removes the currently set callback.
        /// This is called when a monitor is connected to or disconnected from the system.
        /// </para>
        /// </summary>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public partial global::Silk.NET.GLFW.GlfwCallbacks.MonitorCallback SetMonitorCallback(global::Silk.NET.GLFW.GlfwCallbacks.MonitorCallback callback)
        {
            unsafe
            {
                global::System.IntPtr n3;
                Console.WriteLine("Begin SetMonitorCallback");
                Console.WriteLine("PostInit SetMonitorCallback");
                this.PinUntilNextCall((callback), 0);
                Console.WriteLine("PreLoad SetMonitorCallback");
                n3 = ((delegate* unmanaged[Cdecl]<global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetMonitorCallback)((callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
                Console.WriteLine("PostLoad SetMonitorCallback");
                Console.WriteLine("End SetMonitorCallback");
                return (n3 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.MonitorCallback>(n3));
            }
        }

        /// <summary>
        /// <para>
        /// This function sets the mouse button callback of the specified window,
        /// which is called when a mouse button is pressed or released.
        /// </para>
        /// <para>
        /// When a window loses input focus,
        /// it will generate synthetic mouse button release events for all pressed mouse buttons.
        /// You can tell these events from user-generated events by the fact that the synthetic ones are generated after
        /// the focus loss event has been processed,
        /// i.e. after the window focus callback(<see cref = "SetWindowFocusCallback"/>) has been called.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.MouseButtonCallback SetMouseButtonCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.MouseButtonCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetMouseButtonCallback");
            Console.WriteLine("PostInit SetMouseButtonCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetMouseButtonCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetMouseButtonCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetMouseButtonCallback");
            Console.WriteLine("End SetMouseButtonCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.MouseButtonCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the close callback of the specified window,
        /// which is called when the user attempts to close the window,
        /// for example by clicking the close widget in the title bar.
        /// </para>
        /// <para>
        /// The close flag is set before this callback is called,
        /// but you can modify it at any time with <see cref = "SetWindowShouldClose"/>.
        /// </para>
        /// <para>
        /// The close callback is not triggered by <see cref = "DestroyWindow"/>.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// OS X: Selecting Quit from the application menu will trigger the close callback for all windows.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.WindowCloseCallback SetWindowCloseCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.WindowCloseCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetWindowCloseCallback");
            Console.WriteLine("PostInit SetWindowCloseCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetWindowCloseCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetWindowCloseCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetWindowCloseCallback");
            Console.WriteLine("End SetWindowCloseCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.WindowCloseCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the focus callback of the specified window,
        /// which is called when the window gains or loses input focus.
        /// </para>
        /// <para>
        /// After the focus callback is called for a window that lost input focus,
        /// synthetic key and mouse button release events will be generated for all such that had been pressed.
        /// For more information, see <see cref = "SetKeyCallback"/> and <see cref = "SetMouseButtonCallback"/>.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.WindowFocusCallback SetWindowFocusCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.WindowFocusCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetWindowFocusCallback");
            Console.WriteLine("PostInit SetWindowFocusCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetWindowFocusCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetWindowFocusCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetWindowFocusCallback");
            Console.WriteLine("End SetWindowFocusCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.WindowFocusCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the icon of the specified window.
        /// </para>
        /// <para>
        /// If passed an array of candidate images, those of or closest to the sizes desired by the system are selected.
        /// </para>
        /// <para>
        /// If no images are specified, the window reverts to its default icon.
        /// </para>
        /// <para>
        /// The desired image sizes varies depending on platform and system settings.
        /// The selected images will be rescaled as needed. Good sizes include 16x16, 32x32 and 48x48.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose icon to set.</param>
        /// <param name = "count">The number of images in the specified array, or zero to revert to the default window icon.</param>
        /// <param name = "images">The images to create the icon from. This is ignored if count is zero.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// The specified image data is copied before this function returns.
        /// </para>
        /// <para>
        /// OS X: The GLFW window has no icon, as it is not a document window, so this function does nothing.
        /// The dock icon will be the same as the application bundle's icon. For more information on bundles,
        /// see the Bundle Programming Guide in the Mac Developer Library.
        /// </para>
        /// </remarks>
        public unsafe partial void SetWindowIcon(global::Silk.NET.GLFW.WindowHandle* window, int count, global::Silk.NET.GLFW.Image* images)
        {
            Console.WriteLine("Begin SetWindowIcon");
            Console.WriteLine("PostInit SetWindowIcon");
            Console.WriteLine("PreLoad SetWindowIcon");
            ((delegate* unmanaged[Cdecl]<void*, int, void*, void> )(CurrentVTable as GeneratedVTable).glfwSetWindowIcon)(((void*)(window)), (count), ((void*)(images)));
            Console.WriteLine("PostLoad SetWindowIcon");
            Console.WriteLine("End SetWindowIcon");
        }

        /// <summary>
        /// <para>
        /// This function sets the iconification callback of the specified window,
        /// which is called when the window is iconified or restored.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.WindowIconifyCallback SetWindowIconifyCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.WindowIconifyCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetWindowIconifyCallback");
            Console.WriteLine("PostInit SetWindowIconifyCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetWindowIconifyCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetWindowIconifyCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetWindowIconifyCallback");
            Console.WriteLine("End SetWindowIconifyCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.WindowIconifyCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the maximizing callback of the specified window,
        /// which is called when the window is maximized or restored.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.WindowMaximizeCallback SetWindowMaximizeCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.WindowMaximizeCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetWindowMaximizeCallback");
            Console.WriteLine("PostInit SetWindowMaximizeCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetWindowMaximizeCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetWindowMaximizeCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetWindowMaximizeCallback");
            Console.WriteLine("End SetWindowMaximizeCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.WindowMaximizeCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the window title, encoded as UTF-8, of the specified window.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose title to change.</param>
        /// <param name = "title">The UTF-8 encoded window title.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// OS X: The window title will not be updated until the next time you process events.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void SetWindowTitle(global::Silk.NET.GLFW.WindowHandle* window, string title)
        {
            byte* n2;
            Console.WriteLine("Begin SetWindowTitle");
            Console.WriteLine("PostInit SetWindowTitle");
            Console.WriteLine("PreLoad SetWindowTitle");
            n2 = (byte*)Silk.NET.Core.Native.SilkMarshal.StringToPtr((title), (Silk.NET.Core.Native.NativeStringEncoding)48);
            ((delegate* unmanaged[Cdecl]<void*, void*, void> )(CurrentVTable as GeneratedVTable).glfwSetWindowTitle)(((void*)(window)), ((void*)(n2)));
            Console.WriteLine("PostLoad SetWindowTitle");
            title = Silk.NET.Core.Native.SilkMarshal.PtrToString((global::System.IntPtr)(void*)(n2), (Silk.NET.Core.Native.NativeStringEncoding)48);
            Silk.NET.Core.Native.SilkMarshal.FreeString((global::System.IntPtr)n2, (Silk.NET.Core.Native.NativeStringEncoding)48);
            Console.WriteLine("End SetWindowTitle");
        }

        /// <summary>
        /// <para>
        /// This function makes the specified window visible if it was previously hidden.
        /// </para>
        /// <para>
        /// If the window is already visible or is in full screen mode, this function does nothing.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to make visible.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "HideWindow"/>
        public unsafe partial void ShowWindow(global::Silk.NET.GLFW.WindowHandle* window)
        {
            Console.WriteLine("Begin ShowWindow");
            Console.WriteLine("PostInit ShowWindow");
            Console.WriteLine("PreLoad ShowWindow");
            ((delegate* unmanaged[Cdecl]<void*, void> )(CurrentVTable as GeneratedVTable).glfwShowWindow)(((void*)(window)));
            Console.WriteLine("PostLoad ShowWindow");
            Console.WriteLine("End ShowWindow");
        }

        /// <summary>
        /// <para>
        /// This function sets the size, in screen coordinates, of the client area of the specified window.
        /// </para>
        /// <para>
        /// For full screen windows, this function updates the resolution of its desired video mode
        /// and switches to the video mode closest to it, without affecting the window's context.
        /// </para>
        /// <para>
        /// As the context is unaffected, the bit depths of the framebuffer remain unchanged.
        /// </para>
        /// <para>
        /// If you wish to update the refresh rate of the desired video mode in addition to its resolution,
        /// see <see cref = "SetWindowMonitor"/>.
        /// </para>
        /// <para>
        /// The window manager may put limits on what sizes are allowed.
        /// GLFW cannot and should not override these limits.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to resize.</param>
        /// <param name = "width">The desired width, in screen coordinates, of the window client area.</param>
        /// <param name = "height">The desired height, in screen coordinates, of the window client area.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "GetWindowSize"/>
        /// <seealso cref = "SetWindowMonitor"/>
        public unsafe partial void SetWindowSize(global::Silk.NET.GLFW.WindowHandle* window, int width, int height)
        {
            Console.WriteLine("Begin SetWindowSize");
            Console.WriteLine("PostInit SetWindowSize");
            Console.WriteLine("PreLoad SetWindowSize");
            ((delegate* unmanaged[Cdecl]<void*, int, int, void> )(CurrentVTable as GeneratedVTable).glfwSetWindowSize)(((void*)(window)), (width), (height));
            Console.WriteLine("PostLoad SetWindowSize");
            Console.WriteLine("End SetWindowSize");
        }

        /// <summary>
        /// <para>
        /// This function sets the size callback of the specified window, which is called when the window is resized.
        /// The callback is provided with the size, in screen coordinates, of the content area of the window.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.WindowSizeCallback SetWindowSizeCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.WindowSizeCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetWindowSizeCallback");
            Console.WriteLine("PostInit SetWindowSizeCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetWindowSizeCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetWindowSizeCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetWindowSizeCallback");
            Console.WriteLine("End SetWindowSizeCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.WindowSizeCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the framebuffer resize callback of the specified window, which is called when the framebuffer of the specified window is resized.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.FramebufferSizeCallback SetFramebufferSizeCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.FramebufferSizeCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetFramebufferSizeCallback");
            Console.WriteLine("PostInit SetFramebufferSizeCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetFramebufferSizeCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetFramebufferSizeCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetFramebufferSizeCallback");
            Console.WriteLine("End SetFramebufferSizeCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.FramebufferSizeCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the value of the close flag of the specified window.
        /// </para>
        /// <para>
        /// This can be used to override the user's attempt to close the window, or to signal that it should be closed.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose flag to change.</param>
        /// <param name = "value">The new value.</param>
        /// <remarks>
        /// <para>
        /// This function may be called from any thread. Access is not synchronized.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial void SetWindowShouldClose(global::Silk.NET.GLFW.WindowHandle* window, bool value)
        {
            Console.WriteLine("Begin SetWindowShouldClose");
            Console.WriteLine("PostInit SetWindowShouldClose");
            Console.WriteLine("PreLoad SetWindowShouldClose");
            ((delegate* unmanaged[Cdecl]<void*, byte, void> )(CurrentVTable as GeneratedVTable).glfwSetWindowShouldClose)(((void*)(window)), ((value) ? (byte)1 : (byte)0));
            Console.WriteLine("PostLoad SetWindowShouldClose");
            Console.WriteLine("End SetWindowShouldClose");
        }

        /// <summary>
        /// <para>
        /// This function sets the monitor that the window uses for full screen mode or,
        /// if the monitor is <c>null</c>, makes it windowed mode.
        /// </para>
        /// <para>
        /// When setting a monitor, this function updates the width, height and refresh rate
        /// of the desired video mode and switches to the video mode closest to it.
        /// </para>
        /// <para>
        /// The window position is ignored when setting a monitor.
        /// </para>
        /// <para>
        /// When the monitor is <c>null</c>, the position, width and height are used to place the window client area.
        /// The refresh rate is ignored when no monitor is specified.
        /// </para>
        /// <para>
        /// If you only wish to update the resolution of a full screen window or the size of a windowed mode window,
        /// see <see cref = "SetWindowSize"/>.
        /// </para>
        /// <para>
        /// When a window transitions from full screen to windowed mode,
        /// this function restores any previous window settings such as whether it is decorated,
        /// floating, resizable, has size or aspect ratio limits, etc..
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose monitor, size or video mode to set.</param>
        /// <param name = "monitor">The desired monitor, or <c>null</c> to set windowed mode.</param>
        /// <param name = "x">The desired x-coordinate of the upper-left corner of the client area.</param>
        /// <param name = "y">The desired y-coordinate of the upper-left corner of the client area.</param>
        /// <param name = "width">The desired with, in screen coordinates, of the client area or video mode.</param>
        /// <param name = "height">The desired height, in screen coordinates, of the client area or video mode.</param>
        /// <param name = "refreshRate">The desired refresh rate, in Hz, of the video mode, or <see cref = "Glfw.DontCare"/>.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "GetWindowMonitor"/>
        /// <seealso cref = "SetWindowSize"/>
        public unsafe partial void SetWindowMonitor(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.Monitor* monitor, int x, int y, int width, int height, int refreshRate)
        {
            Console.WriteLine("Begin SetWindowMonitor");
            Console.WriteLine("PostInit SetWindowMonitor");
            Console.WriteLine("PreLoad SetWindowMonitor");
            ((delegate* unmanaged[Cdecl]<void*, void*, int, int, int, int, int, void> )(CurrentVTable as GeneratedVTable).glfwSetWindowMonitor)(((void*)(window)), ((void*)(monitor)), (x), (y), (width), (height), (refreshRate));
            Console.WriteLine("PostLoad SetWindowMonitor");
            Console.WriteLine("End SetWindowMonitor");
        }

        /// <summary>
        /// <para>
        /// This function sets the position, in screen coordinates,
        /// of the upper-left corner of the client area of the specified windowed mode window.
        /// </para>
        /// <para>
        /// If the window is a full screen window, this function does nothing.
        /// </para>
        /// <para>
        /// Do not use this function to move an already visible window
        /// unless you have very good reasons for doing so, as it will confuse and annoy the user.
        /// </para>
        /// <para>
        /// The window manager may put limits on what positions are allowed.
        /// GLFW cannot and should not override these limits.
        /// </para>
        /// </summary>
        /// <param name = "window">The window to query.</param>
        /// <param name = "x">The x-coordinate of the upper-left corner of the client area.</param>
        /// <param name = "y">The y-coordinate of the upper-left corner of the client area.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "GetWindowPos"/>
        public unsafe partial void SetWindowPos(global::Silk.NET.GLFW.WindowHandle* window, int x, int y)
        {
            Console.WriteLine("Begin SetWindowPos");
            Console.WriteLine("PostInit SetWindowPos");
            Console.WriteLine("PreLoad SetWindowPos");
            ((delegate* unmanaged[Cdecl]<void*, int, int, void> )(CurrentVTable as GeneratedVTable).glfwSetWindowPos)(((void*)(window)), (x), (y));
            Console.WriteLine("PostLoad SetWindowPos");
            Console.WriteLine("End SetWindowPos");
        }

        /// <summary>
        /// <para>
        /// This function sets the position callback of the specified window, which is called when the window is moved.
        /// </para>
        /// <para>
        /// The callback is provided with the screen position of the upper-left corner of the client area of the window.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.WindowPosCallback SetWindowPosCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.WindowPosCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetWindowPosCallback");
            Console.WriteLine("PostInit SetWindowPosCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetWindowPosCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetWindowPosCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetWindowPosCallback");
            Console.WriteLine("End SetWindowPosCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.WindowPosCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// Sets the refresh callback for the specified window.
        /// </para>
        /// <para>
        /// This function sets the refresh callback of the specified window, which is
        /// called when the content area of the window needs to be redrawn, for example
        /// if the window has been exposed after having been covered by another window.
        /// </para>
        /// <para>
        /// On compositing window systems such as Aero, Compiz, Aqua or Wayland, where
        /// the window contents are saved off-screen, this callback may be called only
        /// very infrequently or never at all.
        /// </para>
        /// </summary>
        /// <param name = "window">The window whose callback to set.</param>
        /// <param name = "callback">The new callback, or <c>null</c> to remove the currently set callback.</param>
        /// <returns>
        /// The previously set callback, or <c>null</c> if no callback was set or the library had not been initialized.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// </remarks>
        public unsafe partial global::Silk.NET.GLFW.GlfwCallbacks.WindowRefreshCallback SetWindowRefreshCallback(global::Silk.NET.GLFW.WindowHandle* window, global::Silk.NET.GLFW.GlfwCallbacks.WindowRefreshCallback callback)
        {
            global::System.IntPtr n5;
            Console.WriteLine("Begin SetWindowRefreshCallback");
            Console.WriteLine("PostInit SetWindowRefreshCallback");
            this.PinUntilNextCall((callback), 0);
            Console.WriteLine("PreLoad SetWindowRefreshCallback");
            n5 = ((delegate* unmanaged[Cdecl]<void*, global::System.IntPtr, global::System.IntPtr> )(CurrentVTable as GeneratedVTable).glfwSetWindowRefreshCallback)(((void*)(window)), (callback == null ? IntPtr.Zero : System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(callback)));
            Console.WriteLine("PostLoad SetWindowRefreshCallback");
            Console.WriteLine("End SetWindowRefreshCallback");
            return (n5 == IntPtr.Zero ? null : System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<global::Silk.NET.GLFW.GlfwCallbacks.WindowRefreshCallback>(n5));
        }

        /// <summary>
        /// <para>
        /// This function sets the swap interval for the current OpenGL or OpenGL ES context,
        /// i.e. the number of screen updates to wait from the time <see cref = "SwapBuffers"/> was called
        /// before swapping the buffers and returning.
        /// This is sometimes called vertical synchronization, vertical retrace synchronization or just vsync.
        /// </para>
        /// <para>
        /// A context that supports either of the <c>WGL_EXT_swap_control_tear</c>
        /// and <c>GLX_EXT_swap_control_tear</c> extensions also accepts negative swap intervals,
        /// which allows the driver to swap immediately even if a frame arrives a little bit late.
        /// You can check for these extensions with <see cref = "ExtensionSupported"/>.
        /// </para>
        /// <para>
        /// A context must be current on the calling thread.
        /// Calling this function without a current context will cause a <see cref = "ErrorCode.NoContext"/> error.
        /// </para>
        /// </summary>
        /// <param name = "interval">
        /// The minimum number of screen updates to wait for until the buffers are swapped by <see cref = "SwapBuffers"/>.
        /// </param>
        /// <remarks>
        /// <para>
        /// This function is not called during context creation,
        /// leaving the swap interval set to whatever is the default on that platform.
        /// This is done because some swap interval extensions used by GLFW
        /// do not allow the swap interval to be reset to zero once it has been set to a non-zero value.
        /// </para>
        /// <para>
        /// Some GPU drivers do not honor the requested swap interval,
        /// either because of a user setting that overrides the application's request or due to bugs in the driver.
        /// </para>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.NoContext"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "SwapBuffers"/>
        public partial void SwapInterval(int interval)
        {
            unsafe
            {
                Console.WriteLine("Begin SwapInterval");
                Console.WriteLine("PostInit SwapInterval");
                Console.WriteLine("PreLoad SwapInterval");
                ((delegate* unmanaged[Cdecl]<int, void> )(CurrentVTable as GeneratedVTable).glfwSwapInterval)((interval));
                Console.WriteLine("PostLoad SwapInterval");
                Console.WriteLine("End SwapInterval");
            }
        }

        /// <summary>
        /// <para>
        /// This function puts the calling thread to sleep until at least one event is available in the event queue.
        /// </para>
        /// <para>
        /// Once one or more events are available, it behaves exactly like <see cref = "PollEvents"/>,
        /// i.e. the events in the queue are processed and the function then returns immediately.
        /// </para>
        /// <para>
        /// Processing events will cause the window and input callbacks associated with those events to be called.
        /// </para>
        /// <para>
        /// Since not all events are associated with callbacks,
        /// this function may return without a callback having been called even if you are monitoring all callbacks.
        /// </para>
        /// <para>
        /// On some platforms, a window move, resize or menu operation will cause event processing to block.
        /// This is due to how event processing is designed on those platforms.
        /// You can use the window refresh callback (<see cref = "SetWindowRefreshCallback"/>)
        /// to redraw the contents of your window when necessary during such operations.
        /// </para>
        /// <para>
        /// On some platforms,
        /// certain callbacks may be called outside of a call to one of the event processing functions.
        /// </para>
        /// <para>
        /// If no windows exist, this function returns immediately.
        /// For synchronization of threads in applications that do not create windows,
        /// use your threading library of choice.
        /// </para>
        /// <para>
        /// Event processing is not required for joystick input to work.
        /// </para>
        /// </summary>
        /// <remarks>
        /// This function must only be called from the main thread.
        /// This function must not be called from a callback.
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </remarks>
        /// <seealso cref = "PollEvents"/>
        /// <seealso cref = "WaitEventsTimeout"/>
        public partial void WaitEvents()
        {
            unsafe
            {
                Console.WriteLine("Begin WaitEvents");
                Console.WriteLine("PostInit WaitEvents");
                Console.WriteLine("PreLoad WaitEvents");
                ((delegate* unmanaged[Cdecl]<void> )(CurrentVTable as GeneratedVTable).glfwWaitEvents)();
                Console.WriteLine("PostLoad WaitEvents");
                Console.WriteLine("End WaitEvents");
            }
        }

        /// <summary>
        /// <para>
        /// This function puts the calling thread to sleep until at least one event is available in the event queue,
        /// or until the specified timeout is reached.
        /// </para>
        /// <para>
        /// If one or more events are available, it behaves exactly like <see cref = "PollEvents"/>,
        /// i.e. the events in the queue are processed and the function then returns immediately.
        /// </para>
        /// <para>
        /// Processing events will cause the window and input callbacks associated with those events to be called.
        /// </para>
        /// <para>
        /// The timeout value must be a positive finite number.
        /// </para>
        /// <para>
        /// Since not all events are associated with callbacks,
        /// this function may return without a callback having been called even if you are monitoring all callbacks.
        /// </para>
        /// <para>
        /// On some platforms, a window move, resize or menu operation will cause event processing to block.
        /// This is due to how event processing is designed on those platforms.
        /// </para>
        /// <para>
        /// You can use the window refresh callback (<see cref = "SetWindowRefreshCallback"/>)
        /// to redraw the contents of your window when necessary during such operations.
        /// </para>
        /// <para>
        /// On some platforms,
        /// certain callbacks may be called outside of a call to one of the event processing functions.
        /// </para>
        /// <para>
        /// If no windows exist, this function returns immediately.
        /// </para>
        /// <para>
        /// For synchronization of threads in applications that do not create windows,
        /// use your threading library of choice.
        /// </para>
        /// <para>
        /// Event processing is not required for joystick input to work.
        /// </para>
        /// </summary>
        /// <param name = "timeout">The maximum amount of time, in seconds, to wait.</param>
        /// <remarks>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// This function must not be called from a callback.
        /// </para>
        /// </remarks>
        /// <seealso cref = "PollEvents"/>
        /// <seealso cref = "WaitEvents"/>
        public partial void WaitEventsTimeout(double timeout)
        {
            unsafe
            {
                Console.WriteLine("Begin WaitEventsTimeout");
                Console.WriteLine("PostInit WaitEventsTimeout");
                Console.WriteLine("PreLoad WaitEventsTimeout");
                ((delegate* unmanaged[Cdecl]<double, void> )(CurrentVTable as GeneratedVTable).glfwWaitEventsTimeout)((timeout));
                Console.WriteLine("PostLoad WaitEventsTimeout");
                Console.WriteLine("End WaitEventsTimeout");
            }
        }

        /// <summary>
        /// <para>
        /// This function returns the contents of the system clipboard,
        /// if it contains or is convertible to a UTF-8 encoded string.
        /// </para>
        /// </summary>
        /// <param name = "window">The window that will request the clipboard contents.</param>
        /// <returns>
        /// The contents of the clipboard as a UTF-8 encoded string, or <c>null</c> if an error occurred.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function may only be called from the main thread.
        /// </para>
        /// <para>
        /// The returned string is allocated and freed by GLFW. You should not free it yourself.
        /// The returned string is valid only until the next call to <see cref = "GetClipboardString"/> or
        /// <see cref = "SetClipboardString"/>.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "SetClipboardString"/>
        public unsafe partial string GetClipboardString(global::Silk.NET.GLFW.WindowHandle* window)
        {
            void* n4;
            Console.WriteLine("Begin GetClipboardString");
            Console.WriteLine("PostInit GetClipboardString");
            Console.WriteLine("PreLoad GetClipboardString");
            n4 = ((delegate* unmanaged[Cdecl]<void*, void*> )(CurrentVTable as GeneratedVTable).glfwGetClipboardString)(((void*)(window)));
            Console.WriteLine("PostLoad GetClipboardString");
            Console.WriteLine("End GetClipboardString");
            return (Silk.NET.Core.Native.SilkMarshal.PtrToString((global::System.IntPtr)((byte*)n4), (Silk.NET.Core.Native.NativeStringEncoding)20));
        }

        /// <summary>
        /// <para>
        /// This function sets the system clipboard to the specified, UTF-8 encoded string.
        /// </para>
        /// </summary>
        /// <param name = "window">The window that will own the clipboard contents. </param>
        /// <param name = "data">A UTF-8 encoded string.</param>
        /// <remarks>
        /// <para>
        /// The specified string is copied before this function returns.
        /// </para>
        /// <para>
        /// This function must only be called from the main thread.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref = "GetClipboardString"/>
        public unsafe partial void SetClipboardString(global::Silk.NET.GLFW.WindowHandle* window, string data)
        {
            byte* n2;
            Console.WriteLine("Begin SetClipboardString");
            Console.WriteLine("PostInit SetClipboardString");
            Console.WriteLine("PreLoad SetClipboardString");
            n2 = (byte*)Silk.NET.Core.Native.SilkMarshal.StringToPtr((data), (Silk.NET.Core.Native.NativeStringEncoding)20);
            ((delegate* unmanaged[Cdecl]<void*, void*, void> )(CurrentVTable as GeneratedVTable).glfwSetClipboardString)(((void*)(window)), ((void*)(n2)));
            Console.WriteLine("PostLoad SetClipboardString");
            data = Silk.NET.Core.Native.SilkMarshal.PtrToString((global::System.IntPtr)(void*)(n2), (Silk.NET.Core.Native.NativeStringEncoding)20);
            Silk.NET.Core.Native.SilkMarshal.FreeString((global::System.IntPtr)n2, (Silk.NET.Core.Native.NativeStringEncoding)20);
            Console.WriteLine("End SetClipboardString");
        }

        /// <summary>
        /// Returns whether the Vulkan loader and an ICD have been found.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function returns whether the Vulkan loader and any minimally functional ICD have been found.
        /// </para>
        /// <para>
        /// The availability of a Vulkan loader and even an ICD does not by itself
        /// guarantee that surface creation or even instance creation is possible.
        /// For example, on Fermi systems Nvidia will install an ICD that provides no actual Vulkan support.
        /// Call <see cref = "GetRequiredInstanceExtensions"/> to check whether the extensions necessary
        /// for Vulkan surface creation are available and <see cref = "GetPhysicalDevicePresentationSupport"/>
        /// to check whether a queue family of a physical device supports image presentation.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>.
        /// </para>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// </remarks>
        /// <returns>
        /// <c>true</c> if Vulkan is minimally available, or <c>false</c> otherwise.
        /// </returns>
        public partial bool VulkanSupported()
        {
            unsafe
            {
                byte n1;
                Console.WriteLine("Begin VulkanSupported");
                Console.WriteLine("PostInit VulkanSupported");
                Console.WriteLine("PreLoad VulkanSupported");
                n1 = ((delegate* unmanaged[Cdecl]<byte> )(CurrentVTable as GeneratedVTable).glfwVulkanSupported)();
                Console.WriteLine("PostLoad VulkanSupported");
                Console.WriteLine("End VulkanSupported");
                return (n1 >= 1);
            }
        }

        /// <summary>
        /// Returns the Vulkan instance extensions required by GLFW.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function returns an array of names of Vulkan instance extensions required by GLFW for
        /// creating Vulkan surfaces for GLFW windows. If successful, the list will always contains
        /// <c>VK_KHR_surface</c>, so if you don't require any additional extensions you can
        /// pass this list directly to the <c>VkInstanceCreateInfo</c> struct.
        /// </para>
        /// <para>
        /// If Vulkan is not available on the machine, this function returns <c>null</c> and generates
        /// a <see cref = "ErrorCode.NotInitialized"/> error. Call <see cref = "VulkanSupported"/> to check
        /// whether Vulkan is at least minimally available.
        /// </para>
        /// <para>
        /// If Vulkan is available but no set of extensions allowing window surface creation was found,
        /// this function returns <c>null</c>. You may still use Vulkan for off-screen rendering and compute work.
        /// </para>
        /// <para>
        /// Additional extensions may be required by future versions of GLFW.
        /// You should check if any extensions you wish to enable are already in the returned array,
        /// as it is an error to specify an extension more than once in the <c>VkInstanceCreateInfo</c> struct.
        /// </para>
        /// <para>
        /// macOS: This function currently only supports the <c>VK_MVK_macos_surface</c> extension from MoltenVK.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.ApiUnavailable"/>.
        /// </para>
        /// <para>
        /// The returned array is allocated and freed by GLFW. You should not free it yourself.
        /// It is guaranteed to be valid only until the library is terminated.
        /// </para>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// </remarks>
        /// <param name = "count">
        /// Where to store the number of extensions in the returned array.
        /// This is set to zero if an error occurred.
        /// </param>
        /// <returns>
        /// An array of ASCII encoded extension names, or <c>null</c> if an error occurred.
        /// </returns>
        public unsafe partial byte** GetRequiredInstanceExtensions(out uint count)
        {
            void* n4;
            Console.WriteLine("Begin GetRequiredInstanceExtensions");
            fixed (uint* SPECIAL_VAR1 = &count)
            {
                Console.WriteLine("PostInit GetRequiredInstanceExtensions");
                Console.WriteLine("PreLoad GetRequiredInstanceExtensions");
                n4 = ((delegate* unmanaged[Cdecl]<void*, void*> )(CurrentVTable as GeneratedVTable).glfwGetRequiredInstanceExtensions)(((void*)(SPECIAL_VAR1)));
                Console.WriteLine("PostLoad GetRequiredInstanceExtensions");
                Console.WriteLine("End GetRequiredInstanceExtensions");
                return ((byte**)n4);
            }
        }

        /// <summary>
        /// Returns the address of the specified Vulkan instance function.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function returns the address of the specified Vulkan core or extension function for
        /// the specified instance. If instance is set to <c>null</c> it can return any function exported
        /// from the Vulkan loader, including at least the following functions:
        /// </para>
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// <c>vkEnumerateInstanceExtensionProperties</c>
        /// </description>
        /// <description>
        /// <c>vkEnumerateInstanceLayerProperties</c>
        /// </description>
        /// <description>
        /// <c>vkCreateInstance</c>
        /// </description>
        /// <description>
        /// <c>vkGetInstanceProcAddr</c>
        /// </description>
        /// </item>
        /// </list>
        /// <para>
        /// If Vulkan is not available on the machine, this function returns <c>null</c> and generates
        /// a <see cref = "ErrorCode.NotInitialized"/> error. Call <see cref = "VulkanSupported"/> to check
        /// whether Vulkan is at least minimally available.
        /// </para>
        /// <para>
        /// This function is equivalent to calling <c>vkGetInstanceProcAddr</c> with a platform-specific
        /// query of the Vulkan loader as a fallback.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.ApiUnavailable"/>.
        /// </para>
        /// <para>
        /// The returned function pointer is valid until the library is terminated.
        /// </para>
        /// </remarks>
        /// <param name = "instance">
        /// The Vulkan instance to query, or <c>null</c> to retrieve functions related to instance creation.
        /// </param>
        /// <param name = "procName">The ASCII encoded name of the function.</param>
        /// <returns>The address of the function, or <c>null</c> if an error occurred.</returns>
        public unsafe partial nint GetInstanceProcAddress(global::Silk.NET.Core.Native.VkHandle instance, byte* procName)
        {
            nint n3;
            Console.WriteLine("Begin GetInstanceProcAddress");
            Console.WriteLine("PostInit GetInstanceProcAddress");
            Console.WriteLine("PreLoad GetInstanceProcAddress");
            n3 = ((delegate* unmanaged[Cdecl]<global::Silk.NET.Core.Native.VkHandle, void*, nint> )(CurrentVTable as GeneratedVTable).glfwGetInstanceProcAddress)((instance), ((void*)(procName)));
            Console.WriteLine("PostLoad GetInstanceProcAddress");
            Console.WriteLine("End GetInstanceProcAddress");
            return n3;
        }

        /// <summary>
        /// Returns whether the specified queue family can present images.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function returns whether the specified queue family of the specified physical device
        /// supports presentation to the platform GLFW was built for.
        /// </para>
        /// <para>
        /// If Vulkan or the required window surface creation instance extensions are not available
        /// on the machine, or if the specified instance was not created with the required extensions,
        /// this function returns <c>false</c> and generates a <see cref = "ErrorCode.ApiUnavailable"/> error.
        /// Call <see cref = "VulkanSupported"/> to check whether Vulkan is at least minimally available and
        /// <see cref = "GetRequiredInstanceExtensions"/> to check what instance extensions are required.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/> and <see cref = "ErrorCode.ApiUnavailable"/>.
        /// </para>
        /// <para>
        /// macOS: This function currently always returns <c>true</c>, as the <c>VK_MVK_macos_surface</c>
        /// extension does not provide a <c>vkGetPhysicalDevice*PresentationSupport</c> type function.
        /// </para>
        /// <para>
        /// This function may be called from any thread.
        /// For synchronization details of Vulkan objects, see the Vulkan specification.
        /// </para>
        /// </remarks>
        /// <param name = "instance">The instance that the physical device belongs to.</param>
        /// <param name = "device">The physical device that the queue family belongs to.</param>
        /// <param name = "queueFamily">The index of the queue family to query.</param>
        /// <returns><c>true</c> if the queue family supports presentation, or <c>false</c> otherwise.</returns>
        public partial bool GetPhysicalDevicePresentationSupport(global::Silk.NET.Core.Native.VkHandle instance, global::Silk.NET.Core.Native.VkHandle device, int queueFamily)
        {
            unsafe
            {
                byte n4;
                Console.WriteLine("Begin GetPhysicalDevicePresentationSupport");
                Console.WriteLine("PostInit GetPhysicalDevicePresentationSupport");
                Console.WriteLine("PreLoad GetPhysicalDevicePresentationSupport");
                n4 = ((delegate* unmanaged[Cdecl]<global::Silk.NET.Core.Native.VkHandle, global::Silk.NET.Core.Native.VkHandle, int, byte> )(CurrentVTable as GeneratedVTable).glfwGetPhysicalDevicePresentationSupport)((instance), (device), (queueFamily));
                Console.WriteLine("PostLoad GetPhysicalDevicePresentationSupport");
                Console.WriteLine("End GetPhysicalDevicePresentationSupport");
                return (n4 >= 1);
            }
        }

        /// <summary>
        /// Creates a Vulkan surface for the specified window.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function creates a Vulkan surface for the specified window.
        /// </para>
        /// <para>
        /// If the Vulkan loader or at least one minimally functional ICD were not found,
        /// this function returns <c>VK_ERROR_INITIALIZATION_FAILED</c> and generates a
        /// <see cref = "ErrorCode.ApiUnavailable"/> error.
        /// Call <see cref = "VulkanSupported"/> to check whether Vulkan is at least minimally available.
        /// </para>
        /// <para>
        /// If the required window surface creation instance extensions are not available or
        /// if the specified instance was not created with these extensions enabled,
        /// this function returns <c>VK_ERROR_EXTENSION_NOT_PRESENT</c> and generates a
        /// <see cref = "ErrorCode.ApiUnavailable"/> error.
        /// Call <see cref = "GetRequiredInstanceExtensions"/> to check what instance extensions are required.
        /// </para>
        /// <para>
        /// The window surface cannot be shared with another API so the window must have been created with
        /// the client api hint set to <see cref = "ClientApi.NoApi"/> otherwise it generates a
        /// <see cref = "ErrorCode.InvalidValue"/> error and returns <c>VK_ERROR_NATIVE_WINDOW_IN_USE_KHR</c>.
        /// </para>
        /// <para>
        /// The window surface must be destroyed before the specified Vulkan instance.
        /// It is the responsibility of the caller to destroy the window surface.
        /// GLFW does not destroy it for you. Call <c>vkDestroySurfaceKHR</c> to destroy the surface.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.ApiUnavailable"/>,
        /// <see cref = "ErrorCode.PlatformError"/> and <see cref = "ErrorCode.InvalidValue"/>.
        /// </para>
        /// <para>
        /// If an error occurs before the creation call is made, GLFW returns the Vulkan error code most
        /// appropriate for the error. Appropriate use of <see cref = "VulkanSupported"/> and
        /// <see cref = "GetRequiredInstanceExtensions"/> should eliminate almost all occurrences of these errors.
        /// </para>
        /// <para>
        /// macOS: This function currently only supports the <c>VK_MVK_macos_surface</c> extension from MoltenVK.
        /// </para>
        /// <para>
        /// macOS: This function creates and sets a <c>CAMetalLayer</c> instance for the window content view,
        /// which is required for MoltenVK to function.
        /// </para>
        /// <para>
        /// This function may be called from any thread.
        /// For synchronization details of Vulkan objects, see the Vulkan specification.
        /// </para>
        /// </remarks>
        /// <param name = "instance">The Vulkan instance to create the surface in.</param>
        /// <param name = "window">The window to create the surface for.</param>
        /// <param name = "allocator">The allocator to use, or <c>null</c> to use the default allocator.</param>
        /// <param name = "surface">
        /// Where to store the handle of the surface.
        /// This is set to <c>VK_NULL_HANDLE</c> if an error occurred.
        /// </param>
        /// <returns>
        /// <c>VK_SUCCESS</c> if successful, or a Vulkan error code if an error occurred.
        /// </returns>
        public unsafe partial int CreateWindowSurface(global::Silk.NET.Core.Native.VkHandle instance, global::Silk.NET.GLFW.WindowHandle* window, void* allocator, global::Silk.NET.Core.Native.VkNonDispatchableHandle* surface)
        {
            int n7;
            Console.WriteLine("Begin CreateWindowSurface");
            Console.WriteLine("PostInit CreateWindowSurface");
            Console.WriteLine("PreLoad CreateWindowSurface");
            n7 = ((delegate* unmanaged[Cdecl]<global::Silk.NET.Core.Native.VkHandle, void*, void*, void*, int> )(CurrentVTable as GeneratedVTable).glfwCreateWindowSurface)((instance), ((void*)(window)), ((void*)(allocator)), ((void*)(surface)));
            Console.WriteLine("PostLoad CreateWindowSurface");
            Console.WriteLine("End CreateWindowSurface");
            return n7;
        }

        /// <summary>
        /// <para>
        /// Returns the address of the specified function for the current context.
        /// </para>
        /// <para>
        /// This function returns the address of the specified OpenGL or OpenGL ES core
        /// or extension function, if it is supported by the current context.
        /// </para>
        /// <para>
        /// A context must be current on the calling thread.  Calling this function without a current context will
        /// cause a <see cref = "ErrorCode.NoContext"/> error. This function does not apply to Vulkan.  If you are rendering
        /// with Vulkan, see <see cref = "GetInstanceProcAddress"/>, <see cref = "GetInstanceProcAddr"/> and
        /// <see cref = "GetDeviceProcAddr"/> instead.
        /// </para>
        /// <para>
        /// Possible errors include <see cref = "ErrorCode.NotInitialized"/>, <see cref = "ErrorCode.NoContext"/> and
        /// <see cref = "ErrorCode.PlatformError"/>.
        /// </para>
        /// <remarks>
        /// <para>
        /// The address of a given function is not guaranteed to be the same between contexts.
        /// </para>
        /// <para>
        /// This function may return a non-<see cref = "IntPtr.Zero"/> address despite the associated version or extension not being
        /// available.  Always check the context version or extension string first.
        /// </para>
        /// <para>
        /// The returned function pointer is valid until the context is destroyed or the library is terminated.
        /// </para>
        /// <para>
        /// This function may be called from any thread.
        /// </para>
        /// </remarks>
        /// </summary>
        /// <param name = "name">The ASCII encoded name of the function.</param>
        /// <returns>The address of the function, or IntPtr.Zero if an error occurred.</returns>
        public partial nint GetProcAddress(string name)
        {
            unsafe
            {
                nint n3;
                byte* n1;
                Console.WriteLine("Begin GetProcAddress");
                Console.WriteLine("PostInit GetProcAddress");
                Console.WriteLine("PreLoad GetProcAddress");
                n1 = (byte*)Silk.NET.Core.Native.SilkMarshal.StringToPtr((name), (Silk.NET.Core.Native.NativeStringEncoding)20);
                n3 = ((delegate* unmanaged[Cdecl]<void*, nint> )(CurrentVTable as GeneratedVTable).glfwGetProcAddress)(((void*)(n1)));
                Console.WriteLine("PostLoad GetProcAddress");
                name = Silk.NET.Core.Native.SilkMarshal.PtrToString((global::System.IntPtr)(void*)(n1), (Silk.NET.Core.Native.NativeStringEncoding)20);
                Silk.NET.Core.Native.SilkMarshal.FreeString((global::System.IntPtr)n1, (Silk.NET.Core.Native.NativeStringEncoding)20);
                Console.WriteLine("End GetProcAddress");
                return n3;
            }
        }

        /// <summary>Retrieves the work area of the monitor.</summary>
        /// <remarks>
        /// <para>
        /// This function returns the position, in screen coordinates, of the upper-left
        /// corner of the work area of the specified monitor along with the work area
        /// size in screen coordinates. The work area is defined as the area of the
        /// monitor not occluded by the operating system task bar where present. If no
        /// task bar exists then the work area is the monitor resolution in screen
        /// coordinates.
        /// </para>
        /// <para>
        /// Any or all of the position and size arguments may be <code>null</code>.  If an error
        /// occurs, all non-<code>null</code> position and size arguments will be set to zero.
        /// </para>
        /// </remarks>
        /// <param name = "monitor">The monitor to query.</param>
        /// <param name = "x">Where to store the monitor x-coordinate, or <code>null</code>.</param>
        /// <param name = "y">Where to store the monitor y-coordinate, or <code>null</code>.</param>
        /// <param name = "width">Where to store the monitor width, or <code>null</code>.</param>
        /// <param name = "height">Where to store the monitor height, or <code>null</code>.</param>
        public unsafe partial void GetMonitorWorkarea(global::Silk.NET.GLFW.Monitor* monitor, out int x, out int y, out int width, out int height)
        {
            Console.WriteLine("Begin GetMonitorWorkarea");
            Console.WriteLine("PostInit GetMonitorWorkarea");
            fixed (int* SPECIAL_VAR5 = &x)
                fixed (int* SPECIAL_VAR6 = &y)
                    fixed (int* SPECIAL_VAR7 = &width)
                        fixed (int* SPECIAL_VAR8 = &height)
                        {
                            Console.WriteLine("PreLoad GetMonitorWorkarea");
                            ((delegate* unmanaged[Cdecl]<void*, void*, void*, void*, void*, void> )(CurrentVTable as GeneratedVTable).glfwGetMonitorWorkarea)(((void*)(monitor)), ((void*)(SPECIAL_VAR5)), ((void*)(SPECIAL_VAR6)), ((void*)(SPECIAL_VAR7)), ((void*)(SPECIAL_VAR8)));
                            Console.WriteLine("PostLoad GetMonitorWorkarea");
                            Console.WriteLine("End GetMonitorWorkarea");
                        }
        }

        protected override int CoreGcSlotCount() => 19 + base.CoreGcSlotCount();
        private sealed class GeneratedVTable : Silk.NET.Core.Native.IVTable
        {
            private Silk.NET.Core.Contexts.INativeContext _ctx;
            internal GeneratedVTable(Silk.NET.Core.Contexts.INativeContext ctx)
            {
                _ctx = ctx;
            }

            private System.IntPtr _glfwInit, _glfwTerminate, _glfwInitHint, _glfwGetVersion, _glfwGetVersionString, _glfwGetError, _glfwGetMonitors, _glfwGetMonitorPos, _glfwGetMonitorPhysicalSize, _glfwGetMonitorContentScale, _glfwGetMonitorName, _glfwSetMonitorUserPointer, _glfwGetMonitorUserPointer, _glfwGetVideoModes, _glfwSetGamma, _glfwGetGammaRamp, _glfwSetGammaRamp, _glfwDefaultWindowHints, _glfwWindowHintString, _glfwSetWindowSizeLimits, _glfwSetWindowAspectRatio, _glfwGetWindowFrameSize, _glfwGetWindowOpacity, _glfwSetWindowOpacity, _glfwRequestWindowAttention, _glfwSetWindowAttrib, _glfwRawMouseMotionSupported, _glfwGetKeyName, _glfwGetKeyScancode, _glfwGetKey, _glfwGetMouseButton, _glfwGetCursorPos, _glfwSetCursorPos, _glfwCreateCursor, _glfwCreateStandardCursor, _glfwDestroyCursor, _glfwSetCursor, _glfwJoystickPresent, _glfwGetJoystickAxes, _glfwGetJoystickButtons, _glfwGetJoystickHats, _glfwGetJoystickName, _glfwGetJoystickGUID, _glfwSetJoystickUserPointer, _glfwGetJoystickUserPointer, _glfwJoystickIsGamepad, _glfwUpdateGamepadMappings, _glfwGetGamepadName, _glfwGetGamepadState, _glfwGetTime, _glfwSetTime, _glfwGetTimerValue, _glfwGetTimerFrequency, _glfwGetCurrentContext, _glfwSwapBuffers, _glfwExtensionSupported, _glfwCreateWindow, _glfwGetPrimaryMonitor, _glfwDestroyWindow, _glfwFocusWindow, _glfwGetFramebufferSize, _glfwGetInputMode, _glfwRestoreWindow, _glfwGetVideoMode, _glfwGetWindowAttrib, _glfwGetWindowSize, _glfwGetWindowPos, _glfwGetWindowMonitor, _glfwHideWindow, _glfwIconifyWindow, _glfwMakeContextCurrent, _glfwMaximizeWindow, _glfwPollEvents, _glfwPostEmptyEvent, _glfwWindowHint, _glfwWindowShouldClose, _glfwSetCharCallback, _glfwSetCharModsCallback, _glfwSetCursorEnterCallback, _glfwSetCursorPosCallback, _glfwSetDropCallback, _glfwSetErrorCallback, _glfwSetInputMode, _glfwSetJoystickCallback, _glfwSetKeyCallback, _glfwSetScrollCallback, _glfwSetMonitorCallback, _glfwSetMouseButtonCallback, _glfwSetWindowCloseCallback, _glfwSetWindowFocusCallback, _glfwSetWindowIcon, _glfwSetWindowIconifyCallback, _glfwSetWindowMaximizeCallback, _glfwSetWindowTitle, _glfwShowWindow, _glfwSetWindowSize, _glfwSetWindowSizeCallback, _glfwSetFramebufferSizeCallback, _glfwSetWindowShouldClose, _glfwSetWindowMonitor, _glfwSetWindowPos, _glfwSetWindowPosCallback, _glfwSetWindowRefreshCallback, _glfwSwapInterval, _glfwWaitEvents, _glfwWaitEventsTimeout, _glfwGetClipboardString, _glfwSetClipboardString, _glfwVulkanSupported, _glfwGetRequiredInstanceExtensions, _glfwGetInstanceProcAddress, _glfwGetPhysicalDevicePresentationSupport, _glfwCreateWindowSurface, _glfwGetProcAddress, _glfwGetMonitorWorkarea;
            public nint Load(int slot, string entryPoint) => Load(entryPoint);
            public nint Load(string entryPoint) => entryPoint switch
            {
                "glfwInit" => glfwInit,
                "glfwTerminate" => glfwTerminate,
                "glfwInitHint" => glfwInitHint,
                "glfwGetVersion" => glfwGetVersion,
                "glfwGetVersionString" => glfwGetVersionString,
                "glfwGetError" => glfwGetError,
                "glfwGetMonitors" => glfwGetMonitors,
                "glfwGetMonitorPos" => glfwGetMonitorPos,
                "glfwGetMonitorPhysicalSize" => glfwGetMonitorPhysicalSize,
                "glfwGetMonitorContentScale" => glfwGetMonitorContentScale,
                "glfwGetMonitorName" => glfwGetMonitorName,
                "glfwSetMonitorUserPointer" => glfwSetMonitorUserPointer,
                "glfwGetMonitorUserPointer" => glfwGetMonitorUserPointer,
                "glfwGetVideoModes" => glfwGetVideoModes,
                "glfwSetGamma" => glfwSetGamma,
                "glfwGetGammaRamp" => glfwGetGammaRamp,
                "glfwSetGammaRamp" => glfwSetGammaRamp,
                "glfwDefaultWindowHints" => glfwDefaultWindowHints,
                "glfwWindowHintString" => glfwWindowHintString,
                "glfwSetWindowSizeLimits" => glfwSetWindowSizeLimits,
                "glfwSetWindowAspectRatio" => glfwSetWindowAspectRatio,
                "glfwGetWindowFrameSize" => glfwGetWindowFrameSize,
                "glfwGetWindowOpacity" => glfwGetWindowOpacity,
                "glfwSetWindowOpacity" => glfwSetWindowOpacity,
                "glfwRequestWindowAttention" => glfwRequestWindowAttention,
                "glfwSetWindowAttrib" => glfwSetWindowAttrib,
                "glfwRawMouseMotionSupported" => glfwRawMouseMotionSupported,
                "glfwGetKeyName" => glfwGetKeyName,
                "glfwGetKeyScancode" => glfwGetKeyScancode,
                "glfwGetKey" => glfwGetKey,
                "glfwGetMouseButton" => glfwGetMouseButton,
                "glfwGetCursorPos" => glfwGetCursorPos,
                "glfwSetCursorPos" => glfwSetCursorPos,
                "glfwCreateCursor" => glfwCreateCursor,
                "glfwCreateStandardCursor" => glfwCreateStandardCursor,
                "glfwDestroyCursor" => glfwDestroyCursor,
                "glfwSetCursor" => glfwSetCursor,
                "glfwJoystickPresent" => glfwJoystickPresent,
                "glfwGetJoystickAxes" => glfwGetJoystickAxes,
                "glfwGetJoystickButtons" => glfwGetJoystickButtons,
                "glfwGetJoystickHats" => glfwGetJoystickHats,
                "glfwGetJoystickName" => glfwGetJoystickName,
                "glfwGetJoystickGUID" => glfwGetJoystickGUID,
                "glfwSetJoystickUserPointer" => glfwSetJoystickUserPointer,
                "glfwGetJoystickUserPointer" => glfwGetJoystickUserPointer,
                "glfwJoystickIsGamepad" => glfwJoystickIsGamepad,
                "glfwUpdateGamepadMappings" => glfwUpdateGamepadMappings,
                "glfwGetGamepadName" => glfwGetGamepadName,
                "glfwGetGamepadState" => glfwGetGamepadState,
                "glfwGetTime" => glfwGetTime,
                "glfwSetTime" => glfwSetTime,
                "glfwGetTimerValue" => glfwGetTimerValue,
                "glfwGetTimerFrequency" => glfwGetTimerFrequency,
                "glfwGetCurrentContext" => glfwGetCurrentContext,
                "glfwSwapBuffers" => glfwSwapBuffers,
                "glfwExtensionSupported" => glfwExtensionSupported,
                "glfwCreateWindow" => glfwCreateWindow,
                "glfwGetPrimaryMonitor" => glfwGetPrimaryMonitor,
                "glfwDestroyWindow" => glfwDestroyWindow,
                "glfwFocusWindow" => glfwFocusWindow,
                "glfwGetFramebufferSize" => glfwGetFramebufferSize,
                "glfwGetInputMode" => glfwGetInputMode,
                "glfwRestoreWindow" => glfwRestoreWindow,
                "glfwGetVideoMode" => glfwGetVideoMode,
                "glfwGetWindowAttrib" => glfwGetWindowAttrib,
                "glfwGetWindowSize" => glfwGetWindowSize,
                "glfwGetWindowPos" => glfwGetWindowPos,
                "glfwGetWindowMonitor" => glfwGetWindowMonitor,
                "glfwHideWindow" => glfwHideWindow,
                "glfwIconifyWindow" => glfwIconifyWindow,
                "glfwMakeContextCurrent" => glfwMakeContextCurrent,
                "glfwMaximizeWindow" => glfwMaximizeWindow,
                "glfwPollEvents" => glfwPollEvents,
                "glfwPostEmptyEvent" => glfwPostEmptyEvent,
                "glfwWindowHint" => glfwWindowHint,
                "glfwWindowShouldClose" => glfwWindowShouldClose,
                "glfwSetCharCallback" => glfwSetCharCallback,
                "glfwSetCharModsCallback" => glfwSetCharModsCallback,
                "glfwSetCursorEnterCallback" => glfwSetCursorEnterCallback,
                "glfwSetCursorPosCallback" => glfwSetCursorPosCallback,
                "glfwSetDropCallback" => glfwSetDropCallback,
                "glfwSetErrorCallback" => glfwSetErrorCallback,
                "glfwSetInputMode" => glfwSetInputMode,
                "glfwSetJoystickCallback" => glfwSetJoystickCallback,
                "glfwSetKeyCallback" => glfwSetKeyCallback,
                "glfwSetScrollCallback" => glfwSetScrollCallback,
                "glfwSetMonitorCallback" => glfwSetMonitorCallback,
                "glfwSetMouseButtonCallback" => glfwSetMouseButtonCallback,
                "glfwSetWindowCloseCallback" => glfwSetWindowCloseCallback,
                "glfwSetWindowFocusCallback" => glfwSetWindowFocusCallback,
                "glfwSetWindowIcon" => glfwSetWindowIcon,
                "glfwSetWindowIconifyCallback" => glfwSetWindowIconifyCallback,
                "glfwSetWindowMaximizeCallback" => glfwSetWindowMaximizeCallback,
                "glfwSetWindowTitle" => glfwSetWindowTitle,
                "glfwShowWindow" => glfwShowWindow,
                "glfwSetWindowSize" => glfwSetWindowSize,
                "glfwSetWindowSizeCallback" => glfwSetWindowSizeCallback,
                "glfwSetFramebufferSizeCallback" => glfwSetFramebufferSizeCallback,
                "glfwSetWindowShouldClose" => glfwSetWindowShouldClose,
                "glfwSetWindowMonitor" => glfwSetWindowMonitor,
                "glfwSetWindowPos" => glfwSetWindowPos,
                "glfwSetWindowPosCallback" => glfwSetWindowPosCallback,
                "glfwSetWindowRefreshCallback" => glfwSetWindowRefreshCallback,
                "glfwSwapInterval" => glfwSwapInterval,
                "glfwWaitEvents" => glfwWaitEvents,
                "glfwWaitEventsTimeout" => glfwWaitEventsTimeout,
                "glfwGetClipboardString" => glfwGetClipboardString,
                "glfwSetClipboardString" => glfwSetClipboardString,
                "glfwVulkanSupported" => glfwVulkanSupported,
                "glfwGetRequiredInstanceExtensions" => glfwGetRequiredInstanceExtensions,
                "glfwGetInstanceProcAddress" => glfwGetInstanceProcAddress,
                "glfwGetPhysicalDevicePresentationSupport" => glfwGetPhysicalDevicePresentationSupport,
                "glfwCreateWindowSurface" => glfwCreateWindowSurface,
                "glfwGetProcAddress" => glfwGetProcAddress,
                "glfwGetMonitorWorkarea" => glfwGetMonitorWorkarea,
                _ => _ctx.GetProcAddress(entryPoint)};
            public nint glfwInit => _glfwInit != default(nint) ? _glfwInit : (_glfwInit = _ctx.GetProcAddress("glfwInit"));
            public nint glfwTerminate => _glfwTerminate != default(nint) ? _glfwTerminate : (_glfwTerminate = _ctx.GetProcAddress("glfwTerminate"));
            public nint glfwInitHint => _glfwInitHint != default(nint) ? _glfwInitHint : (_glfwInitHint = _ctx.GetProcAddress("glfwInitHint"));
            public nint glfwGetVersion => _glfwGetVersion != default(nint) ? _glfwGetVersion : (_glfwGetVersion = _ctx.GetProcAddress("glfwGetVersion"));
            public nint glfwGetVersionString => _glfwGetVersionString != default(nint) ? _glfwGetVersionString : (_glfwGetVersionString = _ctx.GetProcAddress("glfwGetVersionString"));
            public nint glfwGetError => _glfwGetError != default(nint) ? _glfwGetError : (_glfwGetError = _ctx.GetProcAddress("glfwGetError"));
            public nint glfwGetMonitors => _glfwGetMonitors != default(nint) ? _glfwGetMonitors : (_glfwGetMonitors = _ctx.GetProcAddress("glfwGetMonitors"));
            public nint glfwGetMonitorPos => _glfwGetMonitorPos != default(nint) ? _glfwGetMonitorPos : (_glfwGetMonitorPos = _ctx.GetProcAddress("glfwGetMonitorPos"));
            public nint glfwGetMonitorPhysicalSize => _glfwGetMonitorPhysicalSize != default(nint) ? _glfwGetMonitorPhysicalSize : (_glfwGetMonitorPhysicalSize = _ctx.GetProcAddress("glfwGetMonitorPhysicalSize"));
            public nint glfwGetMonitorContentScale => _glfwGetMonitorContentScale != default(nint) ? _glfwGetMonitorContentScale : (_glfwGetMonitorContentScale = _ctx.GetProcAddress("glfwGetMonitorContentScale"));
            public nint glfwGetMonitorName => _glfwGetMonitorName != default(nint) ? _glfwGetMonitorName : (_glfwGetMonitorName = _ctx.GetProcAddress("glfwGetMonitorName"));
            public nint glfwSetMonitorUserPointer => _glfwSetMonitorUserPointer != default(nint) ? _glfwSetMonitorUserPointer : (_glfwSetMonitorUserPointer = _ctx.GetProcAddress("glfwSetMonitorUserPointer"));
            public nint glfwGetMonitorUserPointer => _glfwGetMonitorUserPointer != default(nint) ? _glfwGetMonitorUserPointer : (_glfwGetMonitorUserPointer = _ctx.GetProcAddress("glfwGetMonitorUserPointer"));
            public nint glfwGetVideoModes => _glfwGetVideoModes != default(nint) ? _glfwGetVideoModes : (_glfwGetVideoModes = _ctx.GetProcAddress("glfwGetVideoModes"));
            public nint glfwSetGamma => _glfwSetGamma != default(nint) ? _glfwSetGamma : (_glfwSetGamma = _ctx.GetProcAddress("glfwSetGamma"));
            public nint glfwGetGammaRamp => _glfwGetGammaRamp != default(nint) ? _glfwGetGammaRamp : (_glfwGetGammaRamp = _ctx.GetProcAddress("glfwGetGammaRamp"));
            public nint glfwSetGammaRamp => _glfwSetGammaRamp != default(nint) ? _glfwSetGammaRamp : (_glfwSetGammaRamp = _ctx.GetProcAddress("glfwSetGammaRamp"));
            public nint glfwDefaultWindowHints => _glfwDefaultWindowHints != default(nint) ? _glfwDefaultWindowHints : (_glfwDefaultWindowHints = _ctx.GetProcAddress("glfwDefaultWindowHints"));
            public nint glfwWindowHintString => _glfwWindowHintString != default(nint) ? _glfwWindowHintString : (_glfwWindowHintString = _ctx.GetProcAddress("glfwWindowHintString"));
            public nint glfwSetWindowSizeLimits => _glfwSetWindowSizeLimits != default(nint) ? _glfwSetWindowSizeLimits : (_glfwSetWindowSizeLimits = _ctx.GetProcAddress("glfwSetWindowSizeLimits"));
            public nint glfwSetWindowAspectRatio => _glfwSetWindowAspectRatio != default(nint) ? _glfwSetWindowAspectRatio : (_glfwSetWindowAspectRatio = _ctx.GetProcAddress("glfwSetWindowAspectRatio"));
            public nint glfwGetWindowFrameSize => _glfwGetWindowFrameSize != default(nint) ? _glfwGetWindowFrameSize : (_glfwGetWindowFrameSize = _ctx.GetProcAddress("glfwGetWindowFrameSize"));
            public nint glfwGetWindowOpacity => _glfwGetWindowOpacity != default(nint) ? _glfwGetWindowOpacity : (_glfwGetWindowOpacity = _ctx.GetProcAddress("glfwGetWindowOpacity"));
            public nint glfwSetWindowOpacity => _glfwSetWindowOpacity != default(nint) ? _glfwSetWindowOpacity : (_glfwSetWindowOpacity = _ctx.GetProcAddress("glfwSetWindowOpacity"));
            public nint glfwRequestWindowAttention => _glfwRequestWindowAttention != default(nint) ? _glfwRequestWindowAttention : (_glfwRequestWindowAttention = _ctx.GetProcAddress("glfwRequestWindowAttention"));
            public nint glfwSetWindowAttrib => _glfwSetWindowAttrib != default(nint) ? _glfwSetWindowAttrib : (_glfwSetWindowAttrib = _ctx.GetProcAddress("glfwSetWindowAttrib"));
            public nint glfwRawMouseMotionSupported => _glfwRawMouseMotionSupported != default(nint) ? _glfwRawMouseMotionSupported : (_glfwRawMouseMotionSupported = _ctx.GetProcAddress("glfwRawMouseMotionSupported"));
            public nint glfwGetKeyName => _glfwGetKeyName != default(nint) ? _glfwGetKeyName : (_glfwGetKeyName = _ctx.GetProcAddress("glfwGetKeyName"));
            public nint glfwGetKeyScancode => _glfwGetKeyScancode != default(nint) ? _glfwGetKeyScancode : (_glfwGetKeyScancode = _ctx.GetProcAddress("glfwGetKeyScancode"));
            public nint glfwGetKey => _glfwGetKey != default(nint) ? _glfwGetKey : (_glfwGetKey = _ctx.GetProcAddress("glfwGetKey"));
            public nint glfwGetMouseButton => _glfwGetMouseButton != default(nint) ? _glfwGetMouseButton : (_glfwGetMouseButton = _ctx.GetProcAddress("glfwGetMouseButton"));
            public nint glfwGetCursorPos => _glfwGetCursorPos != default(nint) ? _glfwGetCursorPos : (_glfwGetCursorPos = _ctx.GetProcAddress("glfwGetCursorPos"));
            public nint glfwSetCursorPos => _glfwSetCursorPos != default(nint) ? _glfwSetCursorPos : (_glfwSetCursorPos = _ctx.GetProcAddress("glfwSetCursorPos"));
            public nint glfwCreateCursor => _glfwCreateCursor != default(nint) ? _glfwCreateCursor : (_glfwCreateCursor = _ctx.GetProcAddress("glfwCreateCursor"));
            public nint glfwCreateStandardCursor => _glfwCreateStandardCursor != default(nint) ? _glfwCreateStandardCursor : (_glfwCreateStandardCursor = _ctx.GetProcAddress("glfwCreateStandardCursor"));
            public nint glfwDestroyCursor => _glfwDestroyCursor != default(nint) ? _glfwDestroyCursor : (_glfwDestroyCursor = _ctx.GetProcAddress("glfwDestroyCursor"));
            public nint glfwSetCursor => _glfwSetCursor != default(nint) ? _glfwSetCursor : (_glfwSetCursor = _ctx.GetProcAddress("glfwSetCursor"));
            public nint glfwJoystickPresent => _glfwJoystickPresent != default(nint) ? _glfwJoystickPresent : (_glfwJoystickPresent = _ctx.GetProcAddress("glfwJoystickPresent"));
            public nint glfwGetJoystickAxes => _glfwGetJoystickAxes != default(nint) ? _glfwGetJoystickAxes : (_glfwGetJoystickAxes = _ctx.GetProcAddress("glfwGetJoystickAxes"));
            public nint glfwGetJoystickButtons => _glfwGetJoystickButtons != default(nint) ? _glfwGetJoystickButtons : (_glfwGetJoystickButtons = _ctx.GetProcAddress("glfwGetJoystickButtons"));
            public nint glfwGetJoystickHats => _glfwGetJoystickHats != default(nint) ? _glfwGetJoystickHats : (_glfwGetJoystickHats = _ctx.GetProcAddress("glfwGetJoystickHats"));
            public nint glfwGetJoystickName => _glfwGetJoystickName != default(nint) ? _glfwGetJoystickName : (_glfwGetJoystickName = _ctx.GetProcAddress("glfwGetJoystickName"));
            public nint glfwGetJoystickGUID => _glfwGetJoystickGUID != default(nint) ? _glfwGetJoystickGUID : (_glfwGetJoystickGUID = _ctx.GetProcAddress("glfwGetJoystickGUID"));
            public nint glfwSetJoystickUserPointer => _glfwSetJoystickUserPointer != default(nint) ? _glfwSetJoystickUserPointer : (_glfwSetJoystickUserPointer = _ctx.GetProcAddress("glfwSetJoystickUserPointer"));
            public nint glfwGetJoystickUserPointer => _glfwGetJoystickUserPointer != default(nint) ? _glfwGetJoystickUserPointer : (_glfwGetJoystickUserPointer = _ctx.GetProcAddress("glfwGetJoystickUserPointer"));
            public nint glfwJoystickIsGamepad => _glfwJoystickIsGamepad != default(nint) ? _glfwJoystickIsGamepad : (_glfwJoystickIsGamepad = _ctx.GetProcAddress("glfwJoystickIsGamepad"));
            public nint glfwUpdateGamepadMappings => _glfwUpdateGamepadMappings != default(nint) ? _glfwUpdateGamepadMappings : (_glfwUpdateGamepadMappings = _ctx.GetProcAddress("glfwUpdateGamepadMappings"));
            public nint glfwGetGamepadName => _glfwGetGamepadName != default(nint) ? _glfwGetGamepadName : (_glfwGetGamepadName = _ctx.GetProcAddress("glfwGetGamepadName"));
            public nint glfwGetGamepadState => _glfwGetGamepadState != default(nint) ? _glfwGetGamepadState : (_glfwGetGamepadState = _ctx.GetProcAddress("glfwGetGamepadState"));
            public nint glfwGetTime => _glfwGetTime != default(nint) ? _glfwGetTime : (_glfwGetTime = _ctx.GetProcAddress("glfwGetTime"));
            public nint glfwSetTime => _glfwSetTime != default(nint) ? _glfwSetTime : (_glfwSetTime = _ctx.GetProcAddress("glfwSetTime"));
            public nint glfwGetTimerValue => _glfwGetTimerValue != default(nint) ? _glfwGetTimerValue : (_glfwGetTimerValue = _ctx.GetProcAddress("glfwGetTimerValue"));
            public nint glfwGetTimerFrequency => _glfwGetTimerFrequency != default(nint) ? _glfwGetTimerFrequency : (_glfwGetTimerFrequency = _ctx.GetProcAddress("glfwGetTimerFrequency"));
            public nint glfwGetCurrentContext => _glfwGetCurrentContext != default(nint) ? _glfwGetCurrentContext : (_glfwGetCurrentContext = _ctx.GetProcAddress("glfwGetCurrentContext"));
            public nint glfwSwapBuffers => _glfwSwapBuffers != default(nint) ? _glfwSwapBuffers : (_glfwSwapBuffers = _ctx.GetProcAddress("glfwSwapBuffers"));
            public nint glfwExtensionSupported => _glfwExtensionSupported != default(nint) ? _glfwExtensionSupported : (_glfwExtensionSupported = _ctx.GetProcAddress("glfwExtensionSupported"));
            public nint glfwCreateWindow => _glfwCreateWindow != default(nint) ? _glfwCreateWindow : (_glfwCreateWindow = _ctx.GetProcAddress("glfwCreateWindow"));
            public nint glfwGetPrimaryMonitor => _glfwGetPrimaryMonitor != default(nint) ? _glfwGetPrimaryMonitor : (_glfwGetPrimaryMonitor = _ctx.GetProcAddress("glfwGetPrimaryMonitor"));
            public nint glfwDestroyWindow => _glfwDestroyWindow != default(nint) ? _glfwDestroyWindow : (_glfwDestroyWindow = _ctx.GetProcAddress("glfwDestroyWindow"));
            public nint glfwFocusWindow => _glfwFocusWindow != default(nint) ? _glfwFocusWindow : (_glfwFocusWindow = _ctx.GetProcAddress("glfwFocusWindow"));
            public nint glfwGetFramebufferSize => _glfwGetFramebufferSize != default(nint) ? _glfwGetFramebufferSize : (_glfwGetFramebufferSize = _ctx.GetProcAddress("glfwGetFramebufferSize"));
            public nint glfwGetInputMode => _glfwGetInputMode != default(nint) ? _glfwGetInputMode : (_glfwGetInputMode = _ctx.GetProcAddress("glfwGetInputMode"));
            public nint glfwRestoreWindow => _glfwRestoreWindow != default(nint) ? _glfwRestoreWindow : (_glfwRestoreWindow = _ctx.GetProcAddress("glfwRestoreWindow"));
            public nint glfwGetVideoMode => _glfwGetVideoMode != default(nint) ? _glfwGetVideoMode : (_glfwGetVideoMode = _ctx.GetProcAddress("glfwGetVideoMode"));
            public nint glfwGetWindowAttrib => _glfwGetWindowAttrib != default(nint) ? _glfwGetWindowAttrib : (_glfwGetWindowAttrib = _ctx.GetProcAddress("glfwGetWindowAttrib"));
            public nint glfwGetWindowSize => _glfwGetWindowSize != default(nint) ? _glfwGetWindowSize : (_glfwGetWindowSize = _ctx.GetProcAddress("glfwGetWindowSize"));
            public nint glfwGetWindowPos => _glfwGetWindowPos != default(nint) ? _glfwGetWindowPos : (_glfwGetWindowPos = _ctx.GetProcAddress("glfwGetWindowPos"));
            public nint glfwGetWindowMonitor => _glfwGetWindowMonitor != default(nint) ? _glfwGetWindowMonitor : (_glfwGetWindowMonitor = _ctx.GetProcAddress("glfwGetWindowMonitor"));
            public nint glfwHideWindow => _glfwHideWindow != default(nint) ? _glfwHideWindow : (_glfwHideWindow = _ctx.GetProcAddress("glfwHideWindow"));
            public nint glfwIconifyWindow => _glfwIconifyWindow != default(nint) ? _glfwIconifyWindow : (_glfwIconifyWindow = _ctx.GetProcAddress("glfwIconifyWindow"));
            public nint glfwMakeContextCurrent => _glfwMakeContextCurrent != default(nint) ? _glfwMakeContextCurrent : (_glfwMakeContextCurrent = _ctx.GetProcAddress("glfwMakeContextCurrent"));
            public nint glfwMaximizeWindow => _glfwMaximizeWindow != default(nint) ? _glfwMaximizeWindow : (_glfwMaximizeWindow = _ctx.GetProcAddress("glfwMaximizeWindow"));
            public nint glfwPollEvents => _glfwPollEvents != default(nint) ? _glfwPollEvents : (_glfwPollEvents = _ctx.GetProcAddress("glfwPollEvents"));
            public nint glfwPostEmptyEvent => _glfwPostEmptyEvent != default(nint) ? _glfwPostEmptyEvent : (_glfwPostEmptyEvent = _ctx.GetProcAddress("glfwPostEmptyEvent"));
            public nint glfwWindowHint => _glfwWindowHint != default(nint) ? _glfwWindowHint : (_glfwWindowHint = _ctx.GetProcAddress("glfwWindowHint"));
            public nint glfwWindowShouldClose => _glfwWindowShouldClose != default(nint) ? _glfwWindowShouldClose : (_glfwWindowShouldClose = _ctx.GetProcAddress("glfwWindowShouldClose"));
            public nint glfwSetCharCallback => _glfwSetCharCallback != default(nint) ? _glfwSetCharCallback : (_glfwSetCharCallback = _ctx.GetProcAddress("glfwSetCharCallback"));
            public nint glfwSetCharModsCallback => _glfwSetCharModsCallback != default(nint) ? _glfwSetCharModsCallback : (_glfwSetCharModsCallback = _ctx.GetProcAddress("glfwSetCharModsCallback"));
            public nint glfwSetCursorEnterCallback => _glfwSetCursorEnterCallback != default(nint) ? _glfwSetCursorEnterCallback : (_glfwSetCursorEnterCallback = _ctx.GetProcAddress("glfwSetCursorEnterCallback"));
            public nint glfwSetCursorPosCallback => _glfwSetCursorPosCallback != default(nint) ? _glfwSetCursorPosCallback : (_glfwSetCursorPosCallback = _ctx.GetProcAddress("glfwSetCursorPosCallback"));
            public nint glfwSetDropCallback => _glfwSetDropCallback != default(nint) ? _glfwSetDropCallback : (_glfwSetDropCallback = _ctx.GetProcAddress("glfwSetDropCallback"));
            public nint glfwSetErrorCallback => _glfwSetErrorCallback != default(nint) ? _glfwSetErrorCallback : (_glfwSetErrorCallback = _ctx.GetProcAddress("glfwSetErrorCallback"));
            public nint glfwSetInputMode => _glfwSetInputMode != default(nint) ? _glfwSetInputMode : (_glfwSetInputMode = _ctx.GetProcAddress("glfwSetInputMode"));
            public nint glfwSetJoystickCallback => _glfwSetJoystickCallback != default(nint) ? _glfwSetJoystickCallback : (_glfwSetJoystickCallback = _ctx.GetProcAddress("glfwSetJoystickCallback"));
            public nint glfwSetKeyCallback => _glfwSetKeyCallback != default(nint) ? _glfwSetKeyCallback : (_glfwSetKeyCallback = _ctx.GetProcAddress("glfwSetKeyCallback"));
            public nint glfwSetScrollCallback => _glfwSetScrollCallback != default(nint) ? _glfwSetScrollCallback : (_glfwSetScrollCallback = _ctx.GetProcAddress("glfwSetScrollCallback"));
            public nint glfwSetMonitorCallback => _glfwSetMonitorCallback != default(nint) ? _glfwSetMonitorCallback : (_glfwSetMonitorCallback = _ctx.GetProcAddress("glfwSetMonitorCallback"));
            public nint glfwSetMouseButtonCallback => _glfwSetMouseButtonCallback != default(nint) ? _glfwSetMouseButtonCallback : (_glfwSetMouseButtonCallback = _ctx.GetProcAddress("glfwSetMouseButtonCallback"));
            public nint glfwSetWindowCloseCallback => _glfwSetWindowCloseCallback != default(nint) ? _glfwSetWindowCloseCallback : (_glfwSetWindowCloseCallback = _ctx.GetProcAddress("glfwSetWindowCloseCallback"));
            public nint glfwSetWindowFocusCallback => _glfwSetWindowFocusCallback != default(nint) ? _glfwSetWindowFocusCallback : (_glfwSetWindowFocusCallback = _ctx.GetProcAddress("glfwSetWindowFocusCallback"));
            public nint glfwSetWindowIcon => _glfwSetWindowIcon != default(nint) ? _glfwSetWindowIcon : (_glfwSetWindowIcon = _ctx.GetProcAddress("glfwSetWindowIcon"));
            public nint glfwSetWindowIconifyCallback => _glfwSetWindowIconifyCallback != default(nint) ? _glfwSetWindowIconifyCallback : (_glfwSetWindowIconifyCallback = _ctx.GetProcAddress("glfwSetWindowIconifyCallback"));
            public nint glfwSetWindowMaximizeCallback => _glfwSetWindowMaximizeCallback != default(nint) ? _glfwSetWindowMaximizeCallback : (_glfwSetWindowMaximizeCallback = _ctx.GetProcAddress("glfwSetWindowMaximizeCallback"));
            public nint glfwSetWindowTitle => _glfwSetWindowTitle != default(nint) ? _glfwSetWindowTitle : (_glfwSetWindowTitle = _ctx.GetProcAddress("glfwSetWindowTitle"));
            public nint glfwShowWindow => _glfwShowWindow != default(nint) ? _glfwShowWindow : (_glfwShowWindow = _ctx.GetProcAddress("glfwShowWindow"));
            public nint glfwSetWindowSize => _glfwSetWindowSize != default(nint) ? _glfwSetWindowSize : (_glfwSetWindowSize = _ctx.GetProcAddress("glfwSetWindowSize"));
            public nint glfwSetWindowSizeCallback => _glfwSetWindowSizeCallback != default(nint) ? _glfwSetWindowSizeCallback : (_glfwSetWindowSizeCallback = _ctx.GetProcAddress("glfwSetWindowSizeCallback"));
            public nint glfwSetFramebufferSizeCallback => _glfwSetFramebufferSizeCallback != default(nint) ? _glfwSetFramebufferSizeCallback : (_glfwSetFramebufferSizeCallback = _ctx.GetProcAddress("glfwSetFramebufferSizeCallback"));
            public nint glfwSetWindowShouldClose => _glfwSetWindowShouldClose != default(nint) ? _glfwSetWindowShouldClose : (_glfwSetWindowShouldClose = _ctx.GetProcAddress("glfwSetWindowShouldClose"));
            public nint glfwSetWindowMonitor => _glfwSetWindowMonitor != default(nint) ? _glfwSetWindowMonitor : (_glfwSetWindowMonitor = _ctx.GetProcAddress("glfwSetWindowMonitor"));
            public nint glfwSetWindowPos => _glfwSetWindowPos != default(nint) ? _glfwSetWindowPos : (_glfwSetWindowPos = _ctx.GetProcAddress("glfwSetWindowPos"));
            public nint glfwSetWindowPosCallback => _glfwSetWindowPosCallback != default(nint) ? _glfwSetWindowPosCallback : (_glfwSetWindowPosCallback = _ctx.GetProcAddress("glfwSetWindowPosCallback"));
            public nint glfwSetWindowRefreshCallback => _glfwSetWindowRefreshCallback != default(nint) ? _glfwSetWindowRefreshCallback : (_glfwSetWindowRefreshCallback = _ctx.GetProcAddress("glfwSetWindowRefreshCallback"));
            public nint glfwSwapInterval => _glfwSwapInterval != default(nint) ? _glfwSwapInterval : (_glfwSwapInterval = _ctx.GetProcAddress("glfwSwapInterval"));
            public nint glfwWaitEvents => _glfwWaitEvents != default(nint) ? _glfwWaitEvents : (_glfwWaitEvents = _ctx.GetProcAddress("glfwWaitEvents"));
            public nint glfwWaitEventsTimeout => _glfwWaitEventsTimeout != default(nint) ? _glfwWaitEventsTimeout : (_glfwWaitEventsTimeout = _ctx.GetProcAddress("glfwWaitEventsTimeout"));
            public nint glfwGetClipboardString => _glfwGetClipboardString != default(nint) ? _glfwGetClipboardString : (_glfwGetClipboardString = _ctx.GetProcAddress("glfwGetClipboardString"));
            public nint glfwSetClipboardString => _glfwSetClipboardString != default(nint) ? _glfwSetClipboardString : (_glfwSetClipboardString = _ctx.GetProcAddress("glfwSetClipboardString"));
            public nint glfwVulkanSupported => _glfwVulkanSupported != default(nint) ? _glfwVulkanSupported : (_glfwVulkanSupported = _ctx.GetProcAddress("glfwVulkanSupported"));
            public nint glfwGetRequiredInstanceExtensions => _glfwGetRequiredInstanceExtensions != default(nint) ? _glfwGetRequiredInstanceExtensions : (_glfwGetRequiredInstanceExtensions = _ctx.GetProcAddress("glfwGetRequiredInstanceExtensions"));
            public nint glfwGetInstanceProcAddress => _glfwGetInstanceProcAddress != default(nint) ? _glfwGetInstanceProcAddress : (_glfwGetInstanceProcAddress = _ctx.GetProcAddress("glfwGetInstanceProcAddress"));
            public nint glfwGetPhysicalDevicePresentationSupport => _glfwGetPhysicalDevicePresentationSupport != default(nint) ? _glfwGetPhysicalDevicePresentationSupport : (_glfwGetPhysicalDevicePresentationSupport = _ctx.GetProcAddress("glfwGetPhysicalDevicePresentationSupport"));
            public nint glfwCreateWindowSurface => _glfwCreateWindowSurface != default(nint) ? _glfwCreateWindowSurface : (_glfwCreateWindowSurface = _ctx.GetProcAddress("glfwCreateWindowSurface"));
            public nint glfwGetProcAddress => _glfwGetProcAddress != default(nint) ? _glfwGetProcAddress : (_glfwGetProcAddress = _ctx.GetProcAddress("glfwGetProcAddress"));
            public nint glfwGetMonitorWorkarea => _glfwGetMonitorWorkarea != default(nint) ? _glfwGetMonitorWorkarea : (_glfwGetMonitorWorkarea = _ctx.GetProcAddress("glfwGetMonitorWorkarea"));
            public void Purge()
            {
                _glfwInit = default(nint);
                _glfwTerminate = default(nint);
                _glfwInitHint = default(nint);
                _glfwGetVersion = default(nint);
                _glfwGetVersionString = default(nint);
                _glfwGetError = default(nint);
                _glfwGetMonitors = default(nint);
                _glfwGetMonitorPos = default(nint);
                _glfwGetMonitorPhysicalSize = default(nint);
                _glfwGetMonitorContentScale = default(nint);
                _glfwGetMonitorName = default(nint);
                _glfwSetMonitorUserPointer = default(nint);
                _glfwGetMonitorUserPointer = default(nint);
                _glfwGetVideoModes = default(nint);
                _glfwSetGamma = default(nint);
                _glfwGetGammaRamp = default(nint);
                _glfwSetGammaRamp = default(nint);
                _glfwDefaultWindowHints = default(nint);
                _glfwWindowHintString = default(nint);
                _glfwSetWindowSizeLimits = default(nint);
                _glfwSetWindowAspectRatio = default(nint);
                _glfwGetWindowFrameSize = default(nint);
                _glfwGetWindowOpacity = default(nint);
                _glfwSetWindowOpacity = default(nint);
                _glfwRequestWindowAttention = default(nint);
                _glfwSetWindowAttrib = default(nint);
                _glfwRawMouseMotionSupported = default(nint);
                _glfwGetKeyName = default(nint);
                _glfwGetKeyScancode = default(nint);
                _glfwGetKey = default(nint);
                _glfwGetMouseButton = default(nint);
                _glfwGetCursorPos = default(nint);
                _glfwSetCursorPos = default(nint);
                _glfwCreateCursor = default(nint);
                _glfwCreateStandardCursor = default(nint);
                _glfwDestroyCursor = default(nint);
                _glfwSetCursor = default(nint);
                _glfwJoystickPresent = default(nint);
                _glfwGetJoystickAxes = default(nint);
                _glfwGetJoystickButtons = default(nint);
                _glfwGetJoystickHats = default(nint);
                _glfwGetJoystickName = default(nint);
                _glfwGetJoystickGUID = default(nint);
                _glfwSetJoystickUserPointer = default(nint);
                _glfwGetJoystickUserPointer = default(nint);
                _glfwJoystickIsGamepad = default(nint);
                _glfwUpdateGamepadMappings = default(nint);
                _glfwGetGamepadName = default(nint);
                _glfwGetGamepadState = default(nint);
                _glfwGetTime = default(nint);
                _glfwSetTime = default(nint);
                _glfwGetTimerValue = default(nint);
                _glfwGetTimerFrequency = default(nint);
                _glfwGetCurrentContext = default(nint);
                _glfwSwapBuffers = default(nint);
                _glfwExtensionSupported = default(nint);
                _glfwCreateWindow = default(nint);
                _glfwGetPrimaryMonitor = default(nint);
                _glfwDestroyWindow = default(nint);
                _glfwFocusWindow = default(nint);
                _glfwGetFramebufferSize = default(nint);
                _glfwGetInputMode = default(nint);
                _glfwRestoreWindow = default(nint);
                _glfwGetVideoMode = default(nint);
                _glfwGetWindowAttrib = default(nint);
                _glfwGetWindowSize = default(nint);
                _glfwGetWindowPos = default(nint);
                _glfwGetWindowMonitor = default(nint);
                _glfwHideWindow = default(nint);
                _glfwIconifyWindow = default(nint);
                _glfwMakeContextCurrent = default(nint);
                _glfwMaximizeWindow = default(nint);
                _glfwPollEvents = default(nint);
                _glfwPostEmptyEvent = default(nint);
                _glfwWindowHint = default(nint);
                _glfwWindowShouldClose = default(nint);
                _glfwSetCharCallback = default(nint);
                _glfwSetCharModsCallback = default(nint);
                _glfwSetCursorEnterCallback = default(nint);
                _glfwSetCursorPosCallback = default(nint);
                _glfwSetDropCallback = default(nint);
                _glfwSetErrorCallback = default(nint);
                _glfwSetInputMode = default(nint);
                _glfwSetJoystickCallback = default(nint);
                _glfwSetKeyCallback = default(nint);
                _glfwSetScrollCallback = default(nint);
                _glfwSetMonitorCallback = default(nint);
                _glfwSetMouseButtonCallback = default(nint);
                _glfwSetWindowCloseCallback = default(nint);
                _glfwSetWindowFocusCallback = default(nint);
                _glfwSetWindowIcon = default(nint);
                _glfwSetWindowIconifyCallback = default(nint);
                _glfwSetWindowMaximizeCallback = default(nint);
                _glfwSetWindowTitle = default(nint);
                _glfwShowWindow = default(nint);
                _glfwSetWindowSize = default(nint);
                _glfwSetWindowSizeCallback = default(nint);
                _glfwSetFramebufferSizeCallback = default(nint);
                _glfwSetWindowShouldClose = default(nint);
                _glfwSetWindowMonitor = default(nint);
                _glfwSetWindowPos = default(nint);
                _glfwSetWindowPosCallback = default(nint);
                _glfwSetWindowRefreshCallback = default(nint);
                _glfwSwapInterval = default(nint);
                _glfwWaitEvents = default(nint);
                _glfwWaitEventsTimeout = default(nint);
                _glfwGetClipboardString = default(nint);
                _glfwSetClipboardString = default(nint);
                _glfwVulkanSupported = default(nint);
                _glfwGetRequiredInstanceExtensions = default(nint);
                _glfwGetInstanceProcAddress = default(nint);
                _glfwGetPhysicalDevicePresentationSupport = default(nint);
                _glfwCreateWindowSurface = default(nint);
                _glfwGetProcAddress = default(nint);
                _glfwGetMonitorWorkarea = default(nint);
            }

            public void Dispose()
            {
            }
        }

        protected sealed override IVTable CreateVTable() => new GeneratedVTable(_ctx);
        private sealed unsafe class OVERRIDE_0 : Silk.NET.Core.Contexts.INativeContext
        {
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwInit", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern byte I_glfwInit();
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwTerminate", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwTerminate();
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwInitHint", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwInitHint(int p0, byte p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetVersion", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwGetVersion(void* p0, void* p1, void* p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetVersionString", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetVersionString();
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetError", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern int I_glfwGetError(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetMonitors", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetMonitors(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetMonitorPos", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwGetMonitorPos(void* p0, void* p1, void* p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetMonitorPhysicalSize", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwGetMonitorPhysicalSize(void* p0, void* p1, void* p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetMonitorContentScale", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwGetMonitorContentScale(void* p0, void* p1, void* p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetMonitorName", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetMonitorName(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetMonitorUserPointer", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetMonitorUserPointer(void* p0, nint p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetMonitorUserPointer", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern nint I_glfwGetMonitorUserPointer(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetVideoModes", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetVideoModes(void* p0, void* p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetGamma", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetGamma(void* p0, float p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetGammaRamp", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetGammaRamp(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetGammaRamp", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetGammaRamp(void* p0, void* p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwDefaultWindowHints", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwDefaultWindowHints();
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwWindowHintString", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwWindowHintString(int p0, void* p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowSizeLimits", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetWindowSizeLimits(void* p0, int p1, int p2, int p3, int p4);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowAspectRatio", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetWindowAspectRatio(void* p0, int p1, int p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetWindowFrameSize", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwGetWindowFrameSize(void* p0, void* p1, void* p2, void* p3, void* p4);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetWindowOpacity", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern float I_glfwGetWindowOpacity(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowOpacity", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetWindowOpacity(void* p0, float p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwRequestWindowAttention", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwRequestWindowAttention(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowAttrib", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetWindowAttrib(void* p0, int p1, byte p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwRawMouseMotionSupported", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern byte I_glfwRawMouseMotionSupported();
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetKeyName", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetKeyName(int p0, int p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetKeyScancode", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern int I_glfwGetKeyScancode(int p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetKey", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern int I_glfwGetKey(void* p0, int p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetMouseButton", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern int I_glfwGetMouseButton(void* p0, int p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetCursorPos", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwGetCursorPos(void* p0, void* p1, void* p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetCursorPos", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetCursorPos(void* p0, double p1, double p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwCreateCursor", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwCreateCursor(void* p0, int p1, int p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwCreateStandardCursor", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwCreateStandardCursor(int p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwDestroyCursor", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwDestroyCursor(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetCursor", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetCursor(void* p0, void* p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwJoystickPresent", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern byte I_glfwJoystickPresent(int p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetJoystickAxes", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetJoystickAxes(int p0, void* p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetJoystickButtons", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetJoystickButtons(int p0, void* p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetJoystickHats", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetJoystickHats(int p0, void* p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetJoystickName", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetJoystickName(int p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetJoystickGUID", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetJoystickGUID(int p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetJoystickUserPointer", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetJoystickUserPointer(int p0, nint p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetJoystickUserPointer", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern nint I_glfwGetJoystickUserPointer(int p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwJoystickIsGamepad", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern byte I_glfwJoystickIsGamepad(int p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwUpdateGamepadMappings", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern byte I_glfwUpdateGamepadMappings(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetGamepadName", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetGamepadName(int p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetGamepadState", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern byte I_glfwGetGamepadState(int p0, void* p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetTime", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern double I_glfwGetTime();
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetTime", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetTime(double p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetTimerValue", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern long I_glfwGetTimerValue();
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetTimerFrequency", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern long I_glfwGetTimerFrequency();
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetCurrentContext", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetCurrentContext();
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSwapBuffers", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSwapBuffers(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwExtensionSupported", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern byte I_glfwExtensionSupported(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwCreateWindow", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwCreateWindow(int p0, int p1, void* p2, void* p3, void* p4);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetPrimaryMonitor", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetPrimaryMonitor();
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwDestroyWindow", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwDestroyWindow(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwFocusWindow", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwFocusWindow(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetFramebufferSize", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwGetFramebufferSize(void* p0, void* p1, void* p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetInputMode", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern int I_glfwGetInputMode(void* p0, int p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwRestoreWindow", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwRestoreWindow(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetVideoMode", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetVideoMode(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetWindowAttrib", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern byte I_glfwGetWindowAttrib(void* p0, int p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetWindowSize", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwGetWindowSize(void* p0, void* p1, void* p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetWindowPos", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwGetWindowPos(void* p0, void* p1, void* p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetWindowMonitor", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetWindowMonitor(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwHideWindow", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwHideWindow(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwIconifyWindow", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwIconifyWindow(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwMakeContextCurrent", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwMakeContextCurrent(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwMaximizeWindow", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwMaximizeWindow(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwPollEvents", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwPollEvents();
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwPostEmptyEvent", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwPostEmptyEvent();
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwWindowHint", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwWindowHint(int p0, int p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwWindowShouldClose", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern byte I_glfwWindowShouldClose(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetCharCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetCharCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetCharModsCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetCharModsCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetCursorEnterCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetCursorEnterCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetCursorPosCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetCursorPosCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetDropCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetDropCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetErrorCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetErrorCallback(global::System.IntPtr p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetInputMode", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetInputMode(void* p0, int p1, int p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetJoystickCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetJoystickCallback(global::System.IntPtr p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetKeyCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetKeyCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetScrollCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetScrollCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetMonitorCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetMonitorCallback(global::System.IntPtr p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetMouseButtonCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetMouseButtonCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowCloseCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetWindowCloseCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowFocusCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetWindowFocusCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowIcon", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetWindowIcon(void* p0, int p1, void* p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowIconifyCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetWindowIconifyCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowMaximizeCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetWindowMaximizeCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowTitle", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetWindowTitle(void* p0, void* p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwShowWindow", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwShowWindow(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowSize", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetWindowSize(void* p0, int p1, int p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowSizeCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetWindowSizeCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetFramebufferSizeCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetFramebufferSizeCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowShouldClose", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetWindowShouldClose(void* p0, byte p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowMonitor", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetWindowMonitor(void* p0, void* p1, int p2, int p3, int p4, int p5, int p6);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowPos", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetWindowPos(void* p0, int p1, int p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowPosCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetWindowPosCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetWindowRefreshCallback", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern global::System.IntPtr I_glfwSetWindowRefreshCallback(void* p0, global::System.IntPtr p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSwapInterval", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSwapInterval(int p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwWaitEvents", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwWaitEvents();
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwWaitEventsTimeout", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwWaitEventsTimeout(double p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetClipboardString", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetClipboardString(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwSetClipboardString", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwSetClipboardString(void* p0, void* p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwVulkanSupported", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern byte I_glfwVulkanSupported();
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetRequiredInstanceExtensions", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void* I_glfwGetRequiredInstanceExtensions(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetInstanceProcAddress", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern nint I_glfwGetInstanceProcAddress(global::Silk.NET.Core.Native.VkHandle p0, void* p1);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetPhysicalDevicePresentationSupport", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern byte I_glfwGetPhysicalDevicePresentationSupport(global::Silk.NET.Core.Native.VkHandle p0, global::Silk.NET.Core.Native.VkHandle p1, int p2);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwCreateWindowSurface", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern int I_glfwCreateWindowSurface(global::Silk.NET.Core.Native.VkHandle p0, void* p1, void* p2, void* p3);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetProcAddress", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern nint I_glfwGetProcAddress(void* p0);
            [System.Runtime.InteropServices.DllImport("glfw3", EntryPoint = "glfwGetMonitorWorkarea", CallingConvention = (System.Runtime.InteropServices.CallingConvention)2)]
            private static extern void I_glfwGetMonitorWorkarea(void* p0, void* p1, void* p2, void* p3, void* p4);
            public System.IntPtr GetProcAddress(string proc, int? slot = default)
            {
                var pfn = CoreGetProcAddress(proc, slot);
                if (pfn == System.IntPtr.Zero)
                {
                    throw new InvalidOperationException("Invalid slot");
                }

                return pfn;
            }

            public bool TryGetProcAddress(string proc, out System.IntPtr pfn, int? slot = default) => (pfn = CoreGetProcAddress(proc, slot)) != default(System.IntPtr);
            public IntPtr CoreGetProcAddress(string p, int? s = default)
            {
                return p switch
                {
                    "glfwInit" => (System.IntPtr)(delegate* managed<byte> )(&I_glfwInit),
                    "glfwTerminate" => (System.IntPtr)(delegate* managed<void> )(&I_glfwTerminate),
                    "glfwInitHint" => (System.IntPtr)(delegate* managed<int, byte, void> )(&I_glfwInitHint),
                    "glfwGetVersion" => (System.IntPtr)(delegate* managed<void*, void*, void*, void> )(&I_glfwGetVersion),
                    "glfwGetVersionString" => (System.IntPtr)(delegate* managed<void*> )(&I_glfwGetVersionString),
                    "glfwGetError" => (System.IntPtr)(delegate* managed<void*, int> )(&I_glfwGetError),
                    "glfwGetMonitors" => (System.IntPtr)(delegate* managed<void*, void*> )(&I_glfwGetMonitors),
                    "glfwGetMonitorPos" => (System.IntPtr)(delegate* managed<void*, void*, void*, void> )(&I_glfwGetMonitorPos),
                    "glfwGetMonitorPhysicalSize" => (System.IntPtr)(delegate* managed<void*, void*, void*, void> )(&I_glfwGetMonitorPhysicalSize),
                    "glfwGetMonitorContentScale" => (System.IntPtr)(delegate* managed<void*, void*, void*, void> )(&I_glfwGetMonitorContentScale),
                    "glfwGetMonitorName" => (System.IntPtr)(delegate* managed<void*, void*> )(&I_glfwGetMonitorName),
                    "glfwSetMonitorUserPointer" => (System.IntPtr)(delegate* managed<void*, nint, void> )(&I_glfwSetMonitorUserPointer),
                    "glfwGetMonitorUserPointer" => (System.IntPtr)(delegate* managed<void*, nint> )(&I_glfwGetMonitorUserPointer),
                    "glfwGetVideoModes" => (System.IntPtr)(delegate* managed<void*, void*, void*> )(&I_glfwGetVideoModes),
                    "glfwSetGamma" => (System.IntPtr)(delegate* managed<void*, float, void> )(&I_glfwSetGamma),
                    "glfwGetGammaRamp" => (System.IntPtr)(delegate* managed<void*, void*> )(&I_glfwGetGammaRamp),
                    "glfwSetGammaRamp" => (System.IntPtr)(delegate* managed<void*, void*, void> )(&I_glfwSetGammaRamp),
                    "glfwDefaultWindowHints" => (System.IntPtr)(delegate* managed<void> )(&I_glfwDefaultWindowHints),
                    "glfwWindowHintString" => (System.IntPtr)(delegate* managed<int, void*, void> )(&I_glfwWindowHintString),
                    "glfwSetWindowSizeLimits" => (System.IntPtr)(delegate* managed<void*, int, int, int, int, void> )(&I_glfwSetWindowSizeLimits),
                    "glfwSetWindowAspectRatio" => (System.IntPtr)(delegate* managed<void*, int, int, void> )(&I_glfwSetWindowAspectRatio),
                    "glfwGetWindowFrameSize" => (System.IntPtr)(delegate* managed<void*, void*, void*, void*, void*, void> )(&I_glfwGetWindowFrameSize),
                    "glfwGetWindowOpacity" => (System.IntPtr)(delegate* managed<void*, float> )(&I_glfwGetWindowOpacity),
                    "glfwSetWindowOpacity" => (System.IntPtr)(delegate* managed<void*, float, void> )(&I_glfwSetWindowOpacity),
                    "glfwRequestWindowAttention" => (System.IntPtr)(delegate* managed<void*, void> )(&I_glfwRequestWindowAttention),
                    "glfwSetWindowAttrib" => (System.IntPtr)(delegate* managed<void*, int, byte, void> )(&I_glfwSetWindowAttrib),
                    "glfwRawMouseMotionSupported" => (System.IntPtr)(delegate* managed<byte> )(&I_glfwRawMouseMotionSupported),
                    "glfwGetKeyName" => (System.IntPtr)(delegate* managed<int, int, void*> )(&I_glfwGetKeyName),
                    "glfwGetKeyScancode" => (System.IntPtr)(delegate* managed<int, int> )(&I_glfwGetKeyScancode),
                    "glfwGetKey" => (System.IntPtr)(delegate* managed<void*, int, int> )(&I_glfwGetKey),
                    "glfwGetMouseButton" => (System.IntPtr)(delegate* managed<void*, int, int> )(&I_glfwGetMouseButton),
                    "glfwGetCursorPos" => (System.IntPtr)(delegate* managed<void*, void*, void*, void> )(&I_glfwGetCursorPos),
                    "glfwSetCursorPos" => (System.IntPtr)(delegate* managed<void*, double, double, void> )(&I_glfwSetCursorPos),
                    "glfwCreateCursor" => (System.IntPtr)(delegate* managed<void*, int, int, void*> )(&I_glfwCreateCursor),
                    "glfwCreateStandardCursor" => (System.IntPtr)(delegate* managed<int, void*> )(&I_glfwCreateStandardCursor),
                    "glfwDestroyCursor" => (System.IntPtr)(delegate* managed<void*, void> )(&I_glfwDestroyCursor),
                    "glfwSetCursor" => (System.IntPtr)(delegate* managed<void*, void*, void> )(&I_glfwSetCursor),
                    "glfwJoystickPresent" => (System.IntPtr)(delegate* managed<int, byte> )(&I_glfwJoystickPresent),
                    "glfwGetJoystickAxes" => (System.IntPtr)(delegate* managed<int, void*, void*> )(&I_glfwGetJoystickAxes),
                    "glfwGetJoystickButtons" => (System.IntPtr)(delegate* managed<int, void*, void*> )(&I_glfwGetJoystickButtons),
                    "glfwGetJoystickHats" => (System.IntPtr)(delegate* managed<int, void*, void*> )(&I_glfwGetJoystickHats),
                    "glfwGetJoystickName" => (System.IntPtr)(delegate* managed<int, void*> )(&I_glfwGetJoystickName),
                    "glfwGetJoystickGUID" => (System.IntPtr)(delegate* managed<int, void*> )(&I_glfwGetJoystickGUID),
                    "glfwSetJoystickUserPointer" => (System.IntPtr)(delegate* managed<int, nint, void> )(&I_glfwSetJoystickUserPointer),
                    "glfwGetJoystickUserPointer" => (System.IntPtr)(delegate* managed<int, nint> )(&I_glfwGetJoystickUserPointer),
                    "glfwJoystickIsGamepad" => (System.IntPtr)(delegate* managed<int, byte> )(&I_glfwJoystickIsGamepad),
                    "glfwUpdateGamepadMappings" => (System.IntPtr)(delegate* managed<void*, byte> )(&I_glfwUpdateGamepadMappings),
                    "glfwGetGamepadName" => (System.IntPtr)(delegate* managed<int, void*> )(&I_glfwGetGamepadName),
                    "glfwGetGamepadState" => (System.IntPtr)(delegate* managed<int, void*, byte> )(&I_glfwGetGamepadState),
                    "glfwGetTime" => (System.IntPtr)(delegate* managed<double> )(&I_glfwGetTime),
                    "glfwSetTime" => (System.IntPtr)(delegate* managed<double, void> )(&I_glfwSetTime),
                    "glfwGetTimerValue" => (System.IntPtr)(delegate* managed<long> )(&I_glfwGetTimerValue),
                    "glfwGetTimerFrequency" => (System.IntPtr)(delegate* managed<long> )(&I_glfwGetTimerFrequency),
                    "glfwGetCurrentContext" => (System.IntPtr)(delegate* managed<void*> )(&I_glfwGetCurrentContext),
                    "glfwSwapBuffers" => (System.IntPtr)(delegate* managed<void*, void> )(&I_glfwSwapBuffers),
                    "glfwExtensionSupported" => (System.IntPtr)(delegate* managed<void*, byte> )(&I_glfwExtensionSupported),
                    "glfwCreateWindow" => (System.IntPtr)(delegate* managed<int, int, void*, void*, void*, void*> )(&I_glfwCreateWindow),
                    "glfwGetPrimaryMonitor" => (System.IntPtr)(delegate* managed<void*> )(&I_glfwGetPrimaryMonitor),
                    "glfwDestroyWindow" => (System.IntPtr)(delegate* managed<void*, void> )(&I_glfwDestroyWindow),
                    "glfwFocusWindow" => (System.IntPtr)(delegate* managed<void*, void> )(&I_glfwFocusWindow),
                    "glfwGetFramebufferSize" => (System.IntPtr)(delegate* managed<void*, void*, void*, void> )(&I_glfwGetFramebufferSize),
                    "glfwGetInputMode" => (System.IntPtr)(delegate* managed<void*, int, int> )(&I_glfwGetInputMode),
                    "glfwRestoreWindow" => (System.IntPtr)(delegate* managed<void*, void> )(&I_glfwRestoreWindow),
                    "glfwGetVideoMode" => (System.IntPtr)(delegate* managed<void*, void*> )(&I_glfwGetVideoMode),
                    "glfwGetWindowAttrib" => (System.IntPtr)(delegate* managed<void*, int, byte> )(&I_glfwGetWindowAttrib),
                    "glfwGetWindowSize" => (System.IntPtr)(delegate* managed<void*, void*, void*, void> )(&I_glfwGetWindowSize),
                    "glfwGetWindowPos" => (System.IntPtr)(delegate* managed<void*, void*, void*, void> )(&I_glfwGetWindowPos),
                    "glfwGetWindowMonitor" => (System.IntPtr)(delegate* managed<void*, void*> )(&I_glfwGetWindowMonitor),
                    "glfwHideWindow" => (System.IntPtr)(delegate* managed<void*, void> )(&I_glfwHideWindow),
                    "glfwIconifyWindow" => (System.IntPtr)(delegate* managed<void*, void> )(&I_glfwIconifyWindow),
                    "glfwMakeContextCurrent" => (System.IntPtr)(delegate* managed<void*, void> )(&I_glfwMakeContextCurrent),
                    "glfwMaximizeWindow" => (System.IntPtr)(delegate* managed<void*, void> )(&I_glfwMaximizeWindow),
                    "glfwPollEvents" => (System.IntPtr)(delegate* managed<void> )(&I_glfwPollEvents),
                    "glfwPostEmptyEvent" => (System.IntPtr)(delegate* managed<void> )(&I_glfwPostEmptyEvent),
                    "glfwWindowHint" => (System.IntPtr)(delegate* managed<int, int, void> )(&I_glfwWindowHint),
                    "glfwWindowShouldClose" => (System.IntPtr)(delegate* managed<void*, byte> )(&I_glfwWindowShouldClose),
                    "glfwSetCharCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetCharCallback),
                    "glfwSetCharModsCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetCharModsCallback),
                    "glfwSetCursorEnterCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetCursorEnterCallback),
                    "glfwSetCursorPosCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetCursorPosCallback),
                    "glfwSetDropCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetDropCallback),
                    "glfwSetErrorCallback" => (System.IntPtr)(delegate* managed<global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetErrorCallback),
                    "glfwSetInputMode" => (System.IntPtr)(delegate* managed<void*, int, int, void> )(&I_glfwSetInputMode),
                    "glfwSetJoystickCallback" => (System.IntPtr)(delegate* managed<global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetJoystickCallback),
                    "glfwSetKeyCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetKeyCallback),
                    "glfwSetScrollCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetScrollCallback),
                    "glfwSetMonitorCallback" => (System.IntPtr)(delegate* managed<global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetMonitorCallback),
                    "glfwSetMouseButtonCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetMouseButtonCallback),
                    "glfwSetWindowCloseCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetWindowCloseCallback),
                    "glfwSetWindowFocusCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetWindowFocusCallback),
                    "glfwSetWindowIcon" => (System.IntPtr)(delegate* managed<void*, int, void*, void> )(&I_glfwSetWindowIcon),
                    "glfwSetWindowIconifyCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetWindowIconifyCallback),
                    "glfwSetWindowMaximizeCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetWindowMaximizeCallback),
                    "glfwSetWindowTitle" => (System.IntPtr)(delegate* managed<void*, void*, void> )(&I_glfwSetWindowTitle),
                    "glfwShowWindow" => (System.IntPtr)(delegate* managed<void*, void> )(&I_glfwShowWindow),
                    "glfwSetWindowSize" => (System.IntPtr)(delegate* managed<void*, int, int, void> )(&I_glfwSetWindowSize),
                    "glfwSetWindowSizeCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetWindowSizeCallback),
                    "glfwSetFramebufferSizeCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetFramebufferSizeCallback),
                    "glfwSetWindowShouldClose" => (System.IntPtr)(delegate* managed<void*, byte, void> )(&I_glfwSetWindowShouldClose),
                    "glfwSetWindowMonitor" => (System.IntPtr)(delegate* managed<void*, void*, int, int, int, int, int, void> )(&I_glfwSetWindowMonitor),
                    "glfwSetWindowPos" => (System.IntPtr)(delegate* managed<void*, int, int, void> )(&I_glfwSetWindowPos),
                    "glfwSetWindowPosCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetWindowPosCallback),
                    "glfwSetWindowRefreshCallback" => (System.IntPtr)(delegate* managed<void*, global::System.IntPtr, global::System.IntPtr> )(&I_glfwSetWindowRefreshCallback),
                    "glfwSwapInterval" => (System.IntPtr)(delegate* managed<int, void> )(&I_glfwSwapInterval),
                    "glfwWaitEvents" => (System.IntPtr)(delegate* managed<void> )(&I_glfwWaitEvents),
                    "glfwWaitEventsTimeout" => (System.IntPtr)(delegate* managed<double, void> )(&I_glfwWaitEventsTimeout),
                    "glfwGetClipboardString" => (System.IntPtr)(delegate* managed<void*, void*> )(&I_glfwGetClipboardString),
                    "glfwSetClipboardString" => (System.IntPtr)(delegate* managed<void*, void*, void> )(&I_glfwSetClipboardString),
                    "glfwVulkanSupported" => (System.IntPtr)(delegate* managed<byte> )(&I_glfwVulkanSupported),
                    "glfwGetRequiredInstanceExtensions" => (System.IntPtr)(delegate* managed<void*, void*> )(&I_glfwGetRequiredInstanceExtensions),
                    "glfwGetInstanceProcAddress" => (System.IntPtr)(delegate* managed<global::Silk.NET.Core.Native.VkHandle, void*, nint> )(&I_glfwGetInstanceProcAddress),
                    "glfwGetPhysicalDevicePresentationSupport" => (System.IntPtr)(delegate* managed<global::Silk.NET.Core.Native.VkHandle, global::Silk.NET.Core.Native.VkHandle, int, byte> )(&I_glfwGetPhysicalDevicePresentationSupport),
                    "glfwCreateWindowSurface" => (System.IntPtr)(delegate* managed<global::Silk.NET.Core.Native.VkHandle, void*, void*, void*, int> )(&I_glfwCreateWindowSurface),
                    "glfwGetProcAddress" => (System.IntPtr)(delegate* managed<void*, nint> )(&I_glfwGetProcAddress),
                    "glfwGetMonitorWorkarea" => (System.IntPtr)(delegate* managed<void*, void*, void*, void*, void*, void> )(&I_glfwGetMonitorWorkarea),
                    _ => default(nint)};
            }

            public void Dispose()
            {
            }
        }

        public static INativeContext CreateDefaultContext(string n)
        {
            if (n == "glfw3")
                return new OVERRIDE_0();
            else
                return new Silk.NET.Core.Contexts.DefaultNativeContext(n);
        }
    }
}