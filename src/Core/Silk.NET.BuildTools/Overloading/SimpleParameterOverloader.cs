// This file is part of Silk.NET.
// 
// You may modify and distribute Silk.NET under the terms
// of the MIT license. See the LICENSE file for details.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Silk.NET.BuildTools.Common;
using Silk.NET.BuildTools.Common.Builders;
using Silk.NET.BuildTools.Common.Functions;

namespace Silk.NET.BuildTools.Overloading
{
    /// <summary>
    /// Creates simple function overloads.
    /// </summary>
    ///<remarks>
    /// It is "simple" in the sense that:
    /// <list type="bullet">
    /// <item><description>The signatures it generates are SilkTouch compatible.</description></item>
    /// <item><description>No extra code is needed in order to make the function work.</description></item>
    /// </list>
    /// While this is the simplest overloading step, it is the one that has the most impact.
    /// </remarks>
    public static class SimpleParameterOverloader
    {
        /// <summary>
        /// Returns an enumerable containing the original function signature, as well as all overload variants
        /// generated by the 
        /// </summary>
        /// <param name="original">The original function signature.</param>
        /// <param name="core">The core project for this profile. May be used by some overloads.</param>
        /// <param name="overloaders">The overloaders to use in getting function overloads.</param>
        /// <returns>An enumerable containing the original function signature and all overloads.</returns>
        public static IEnumerable<Function> GetWithOverloads(Function original,
            Project core,
            params ISimpleParameterOverloader[] overloaders)
        {
            var parameters = original.Parameters.Select(x => new List<Parameter> {x}).ToList();
            foreach (var parameter in parameters)
            {
                foreach (var overloader in overloaders)
                {
                    if (overloader.TryGetParameterVariant(parameter[0], out var variant, core))
                    {
                        parameter.Add(variant);
                    }
                }
            }

            foreach (var combination in Combinations(parameters))
            {
                yield return new FunctionSignatureBuilder(original).WithParameters(combination).Build();
            }
        }
        
        [SuppressMessage("ReSharper", "PossibleMultipleEnumeration")]
        private static IEnumerable<IReadOnlyList<T>> Combinations<T>(IEnumerable<IReadOnlyList<T>> collections)
        {
            // Any multiple enumeration will be benign and enumerating to an array or list is a needless allocation.
            if (collections.Count() == 1)
            {
                foreach (var item in collections.Single())
                    yield return new List<T> { item };
            }
            else if (collections.Count() > 1)
            {
                foreach (var item in collections.First())
                foreach (var tail in Combinations(collections.Skip(1)))
                    yield return new[] { item }.Concat(tail).ToList();
            }
        }
    }
}
